<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loserbird&#39;s Blog</title>
  
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-26T09:14:11.075Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Loserbird</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态代理</title>
    <link href="http://yoursite.com/2017/11/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2017/11/26/动态代理/</id>
    <published>2017-11-26T09:13:19.000Z</published>
    <updated>2017-11-26T09:14:11.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h4 id="如何动态创建一个类"><a href="#如何动态创建一个类" class="headerlink" title="如何动态创建一个类"></a>如何动态创建一个类</h4><p> 由于JVM通过字节码的二进制信息加载类的，那么，如果在运行期系统中，遵循Java编译系统组织.class文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类，这样，就完成了在代码中，动态创建一个类的能力了。当前有很多开源框架可以完成这些功能，如ASM，Javassist。</p><h2 id="JKD动态代理"><a href="#JKD动态代理" class="headerlink" title="JKD动态代理"></a>JKD动态代理</h2><p>JDK的动态代理，就是在程序运行的过程中，根据被代理的接口来动态生成代理类的class文件，并加载运行的过程。</p><h3 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy#newProxyInstance"></a>Proxy#newProxyInstance</h3><h3 id="InvocationHandler-invoke"><a href="#InvocationHandler-invoke" class="headerlink" title="InvocationHandler#invoke"></a>InvocationHandler#invoke</h3><h3 id="使用动态代理的五大步骤"><a href="#使用动态代理的五大步骤" class="headerlink" title="使用动态代理的五大步骤"></a>使用动态代理的五大步骤</h3><ol><li><p>通过实现InvocationHandler接口来自定义自己的InvocationHandler;</p></li><li><p>通过Proxy.getProxyClass获得动态代理类</p></li><li><p>通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)</p></li><li><p>通过构造函数获得代理对象并将自定义的InvocationHandler实例对象传为参数传入</p></li><li><p>通过代理对象调用目标方法</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>UserService接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface UserService &#123;</div><div class="line">public String getName(int id); </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>UserService实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class UserServiceImpl implements UserService&#123;</div><div class="line"> @Override  </div><div class="line">    public String getName(int id) &#123;  </div><div class="line"> System.out.println(&quot;UserServiceImpl#getName invoke&quot;);</div><div class="line">        return &quot;user &quot;+id;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代理类对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class MyInvocationHandler implements InvocationHandler&#123;</div><div class="line">private UserService target;</div><div class="line"></div><div class="line">public  MyInvocationHandler(UserService target) &#123;</div><div class="line">this.target = target;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line">System.out.println(&quot;----before---&quot;);</div><div class="line">Object result = method.invoke(target,args);</div><div class="line">System.out.println(&quot;---after-----&quot;);</div><div class="line">return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</div><div class="line">UserService target = new UserServiceImpl();</div><div class="line">MyInvocationHandler invocationHandler = new MyInvocationHandler(target);</div><div class="line">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</div><div class="line">ClassLoader loader = target.getClass().getClassLoader();</div><div class="line">Class[] interfaces = target.getClass().getInterfaces();</div><div class="line">UserService userService = (UserService) Proxy.newProxyInstance(loader, interfaces, invocationHandler);</div><div class="line">//Proxy.newProxyInstance是对下面过程的封装</div><div class="line">//Class proxyClass = Proxy.getProxyClass(loader, interfaces);</div><div class="line">//Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);</div><div class="line">//UserService userService = (UserService) constructor.newInstance(invocationHandler);</div><div class="line">userService.getName(1);</div><div class="line">System.out.println(userService.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> CGLIB是一个强大的高性能的代码生成包 .它广泛的被许多AOP的框架使用,例如spring AOP .诸如 EasyMock和JMock 等通过模仿对象来测试Java代码的包都使用CGLIB.他们都通过使用CGLIB来为那些没有实现接口的类创建代理。</p><p> CGLIB底层通过一个小而快的字节码处理框架ASM ,来转换字节码并生成新的类.ASM是底层的字节码生成工具,使用ASM已经近乎接近使用Java bytecode编程,而使用CGLIB更像是对ASM进行的高级化封装。</p><h3 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h3><p>方法拦截器。在调用目标方法时，CGLib会回调MethodInterceptor接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class CglibProxy implements MethodInterceptor&#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</div><div class="line">System.out.println(&quot;--before&quot;);</div><div class="line">Object result = proxy.invokeSuper(obj, args);</div><div class="line">System.out.println(&quot;---after&quot;);</div><div class="line">return result;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">Enhancer enhancer = new Enhancer();</div><div class="line">enhancer.setSuperclass(Po.class);</div><div class="line">enhancer.setCallback(new CglibProxy());</div><div class="line"></div><div class="line">Po po = (Po) enhancer.create();</div><div class="line">po.sayHello();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Po &#123;</div><div class="line">public void sayHello()&#123;</div><div class="line">System.out.println(&quot;sayHello&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="NoOp-INSTANCE"><a href="#NoOp-INSTANCE" class="headerlink" title="NoOp.INSTANCE"></a>NoOp.INSTANCE</h3><p>默认父类实现</p><h3 id="CallbackFilter"><a href="#CallbackFilter" class="headerlink" title="CallbackFilter"></a>CallbackFilter</h3><p>在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。<br>在JDK动态代理中并没有类似的功能，对InvocationHandler接口方法的调用对代理类内的所以方法都有效。 </p><h3 id="使用cglib实现延迟加载"><a href="#使用cglib实现延迟加载" class="headerlink" title="使用cglib实现延迟加载"></a>使用cglib实现延迟加载</h3><h3 id="LazyLoader"><a href="#LazyLoader" class="headerlink" title="LazyLoader"></a>LazyLoader</h3><p> LazyLoader接口继承了Callback。利用它来回调进行初始化。<br> 原理：对需要延迟加载的对象添加代理，在获取该对象属性时先通过代理类回调方法进行对象初始化。在不需要加载该对象时，只要不去获取该对象内属性，该对象就不会被初始化了（在CGLib的实现中,当第一次去访问该对象内属性的getter方法时，就会自动触发代理类回调）。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> public class Loader &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">Enhancer enhancer = new Enhancer();</div><div class="line">enhancer.setSuperclass(PO.class);</div><div class="line">LazyLoader lazyLoader = new LazyLoader()&#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public Object loadObject() throws Exception &#123;</div><div class="line">System.out.println(&quot;initilize&quot;);</div><div class="line">PO po = new PO();</div><div class="line">po.setName(&quot;hello&quot;);</div><div class="line">return po;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">enhancer.setCallback(lazyLoader);</div><div class="line">PO po = (PO) enhancer.create();</div><div class="line">System.out.println(&quot;----&quot;);</div><div class="line">System.out.println(po.getName());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Dispatcher接口同样继承于Callback，也是一种回调类型。<br>但是Dispatcher和LazyLoader的区别在于：LazyLoader只在第一次访问延迟加载属性时触发代理类回调方法，而Dispatcher在每次访问延迟加载属性时都会触发代理类回调方法。</p><h2 id="Java字节码生成开源框架介绍–Javassist"><a href="#Java字节码生成开源框架介绍–Javassist" class="headerlink" title="Java字节码生成开源框架介绍–Javassist"></a>Java字节码生成开源框架介绍–Javassist</h2><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class JavassistGenerator &#123;</div><div class="line">public static void main(String[] args) throws CannotCompileException, IOException &#123;</div><div class="line">ClassPool pool = ClassPool.getDefault();</div><div class="line">CtClass ctClass = pool.makeClass(&quot;Sample&quot;);</div><div class="line">CtMethod method = CtNewMethod.make(&quot;public void sayHello()&#123;&#125;&quot;,ctClass);</div><div class="line">method.insertBefore(&quot;System.out.println(\&quot;hello world..\&quot;);&quot;);</div><div class="line">ctClass.addMethod(method);</div><div class="line">ctClass.writeFile(&quot;d://work&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h1&gt;&lt;h4 id=&quot;如何动态创建一个类&quot;&gt;&lt;a href=&quot;#如何动态创建一个类&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常见web安全问题</title>
    <link href="http://yoursite.com/2017/11/26/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/26/常见web安全问题/</id>
    <published>2017-11-26T08:36:00.000Z</published>
    <updated>2017-11-26T08:36:40.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>cross site scripting<br>跨站脚本攻击</p><p>分类：<br>反射型：url参数直接注入<br>储存型：存储到DB后读取时注入</p><p>攻击注入点：<br>HTML节点内容<br>HTML属性<br>Javascript代码<br>富文本</p><p>如何防御？</p><ol><li>浏览器自身的防御机制。防御反射型注入。只适用于HTML节点内容，<br>HTML属性的防御。</li><li>对尖括号进行转义。&lt;&gt;(HTML节点）</li><li>对引号进行转义。&quto;（双引号），&amp;#39(单引号），（HTML属性）</li><li>js内容的防御，对斜杠进行转义。</li><li>富文本内容的防御，制作黑名单对文本进行过滤。或者制作白名单只对需保留的元素保留，其它移除。</li><li>CSP:内容保护协议。加一个HTTP请求头，Content-Security-Policy,可以指定哪些脚本可以被执行，哪些不可以。例如可以设置只有同域下的脚本才可以被执行。</li></ol><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>Cross Site Request Forgy<br>跨站请求伪造</p><p>XSS是在本站执行了别的站点的脚本，而CSRF是从其它站点发个请求到本站。通常是通过用户点击某个链接或者带有src的图片来向目标网站发请求。而此时浏览器中如果带有用户标识的cookie就比较危险。</p><p>原理：</p><ol><li>用户访问A网站</li><li>A网站确认身份并返回cookie</li><li>B网站页面向A网站发起请求（携带A网站身份）</li></ol><p>防御：</p><ol><li>cookie有个sameSite属性，设置cookie的samesite属性为strict,则只允许同站点的请求带上cookie.但是目前只有chrome,opeara浏览器支持这个属性。</li><li>在A网站前端页面加入一些验证信息，例如验证码或者token.B网站是无法提前知道这些信息的。</li><li>验证Refere,禁止来自第三方网站的请求。<h3 id="点击挟持"><a href="#点击挟持" class="headerlink" title="点击挟持"></a>点击挟持</h3>用iframe隐藏目标网站，用户 点击会发送请求。但是用户不知情。</li></ol><p>如何防御？</p><ol><li>用javascript禁止内嵌iframe.(但是可以用iframe的sandbox属性禁止javascript)</li><li>可以设置请求头X-frame-Options为deny禁止内嵌。</li></ol><h3 id="http请求窃听篡改"><a href="#http请求窃听篡改" class="headerlink" title="http请求窃听篡改"></a>http请求窃听篡改</h3><p>http请求中经过的节点都有可能窃听篡改http请求的内容。如中间代理等。<br>可以通过加一层TLS层变成HTTPS请求来加密传输内容。但是这样也会有一个中间人攻击的危险。可以通过验证证书的机制来验证服务器的身份。证书通过CA颁发。</p><h3 id="sql注入防御"><a href="#sql注入防御" class="headerlink" title="sql注入防御"></a>sql注入防御</h3><ol><li>关闭错误输出</li><li>检查数据类型</li><li>对数据进行转义（escape）</li><li>使用参数化查询</li><li>使用ORM(对象关系映射）</li></ol><p>nosql也有注入的问题</p><h3 id="上传问题"><a href="#上传问题" class="headerlink" title="上传问题"></a>上传问题</h3><ol><li>限制上传后缀</li><li>文件类型检查</li><li>文件内容检查</li><li>程序输出。读出文件内容再输出给浏览器。不给文件执行的机会。</li><li>权限控制。可写可执行互斥。</li></ol><h3 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h3><p>发起大量请求，导致服务器瘫痪。</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>请求被窃听或记录<br>再次发起相同的请求<br>产生意外的结果</p><p>问题：<br>用户可能被多次消费<br>登录态被盗取<br>多次抽奖</p><p>防御：<br>加密（HTTPS）<br>加时间戳<br>token(seesion)<br>nonce(随机数）<br>签名（防止被篡改）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;headerlink&quot; title=&quot;XSS&quot;&gt;&lt;/a&gt;XSS&lt;/h3&gt;&lt;p&gt;cross site scripting&lt;br&gt;跨站脚本攻击&lt;/p&gt;
&lt;p&gt;分类：&lt;br&gt;反射型：url参数直接注入&lt;br&gt;储存型：
      
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>经典面试题之二叉树</title>
    <link href="http://yoursite.com/2017/11/26/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/11/26/经典面试题之二叉树/</id>
    <published>2017-11-26T08:33:46.000Z</published>
    <updated>2017-11-26T08:34:40.318Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树从左到右顺序打印并换行"><a href="#二叉树从左到右顺序打印并换行" class="headerlink" title="二叉树从左到右顺序打印并换行"></a>二叉树从左到右顺序打印并换行</h3><p>思路：用队列实现层次遍历。增加两个变量，last（指向当前层的最后一个节点），nlast指向下一层的最后一个节点。初始时令last等于根节点。令nlast始终等于最新加入队列中的节点。当出队的节点是last时，更新last=nlast.直到循环结束。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static void printNode(BinaryTreeNode root)&#123;</div><div class="line">Queue&lt;BinaryTreeNode&gt; queue = new LinkedList&lt;&gt;();</div><div class="line">queue.offer(root);</div><div class="line">BinaryTreeNode last = root;</div><div class="line">BinaryTreeNode nlast = root;</div><div class="line">while(!queue.isEmpty())&#123;</div><div class="line">BinaryTreeNode node = queue.poll();</div><div class="line">System.out.print(node.getData()+&quot; &quot;);</div><div class="line">if(node.getLeft() != null)&#123;</div><div class="line">queue.offer(node.getLeft());</div><div class="line">nlast = node.getLeft();</div><div class="line">&#125;</div><div class="line">if(node.getRight() != null)&#123;</div><div class="line">queue.offer(node.getRight());</div><div class="line">nlast = node.getRight();</div><div class="line">&#125;</div><div class="line">if(node == last)&#123;</div><div class="line">System.out.println();</div><div class="line">last = nlast;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="序列化和反序列化二叉树"><a href="#序列化和反序列化二叉树" class="headerlink" title="序列化和反序列化二叉树"></a>序列化和反序列化二叉树</h3><p>思路：可用先序遍历把二叉树序列化到文件中，形式为字符串。再把字符串从文件中读取出来，反序列化为二叉树,方式也为先序遍历。把非空节点序列化为节点值+！（也可以为其它特殊节点，标识一个节点值的结束），把空节点标识为#！。</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//序列化,把序列化后的字符串放到list中。</div><div class="line">public static void serialize(BinaryTreeNode node,ArrayList&lt;String&gt; list)&#123;</div><div class="line">if(node != null)&#123;</div><div class="line">list.add(node.getData()+&quot;!&quot;);</div><div class="line">serialize(node.getLeft(), list);</div><div class="line">serialize(node.getRight(), list);</div><div class="line">&#125;else&#123;</div><div class="line">list.add(&quot;#!&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//反序列化并返回根节点</div><div class="line">public static BinaryTreeNode deserialize(ArrayList&lt;String&gt; list)&#123;</div><div class="line">if(list == null || list.size() == 0)&#123;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line">String strdata = list.get(0);</div><div class="line">list.remove(0);</div><div class="line">if(strdata.equals(&quot;#!&quot;))&#123;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line">int data = Integer.valueOf(strdata.substring(0, strdata.indexOf(&apos;!&apos;)));</div><div class="line">BinaryTreeNode node = new BinaryTreeNode(data);</div><div class="line">node.setLeft(deserialize(list));</div><div class="line">node.setRight(deserialize(list));</div><div class="line">return node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树从左到右顺序打印并换行&quot;&gt;&lt;a href=&quot;#二叉树从左到右顺序打印并换行&quot; class=&quot;headerlink&quot; title=&quot;二叉树从左到右顺序打印并换行&quot;&gt;&lt;/a&gt;二叉树从左到右顺序打印并换行&lt;/h3&gt;&lt;p&gt;思路：用队列实现层次遍历。增加两个变量，la
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://yoursite.com/2017/11/26/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/11/26/git常用命令/</id>
    <published>2017-11-26T08:24:19.000Z</published>
    <updated>2017-11-26T08:27:35.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git特点"><a href="#git特点" class="headerlink" title="git特点"></a>git特点</h3><p>直接记录快照，而非差异比较。每次提交更新，主要对当时的全部文件制作一个快照并保存这个快照的索引。</p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><p><code>git add file</code></p><p>查看文件状态</p><p><code>git status</code><br>克隆仓库<br><code>git clone remoteurl</code></p><h3 id="查看提交历史："><a href="#查看提交历史：" class="headerlink" title="查看提交历史："></a>查看提交历史：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">//-p用来显示每次提交的内容差异</div><div class="line">git log -p -2</div><div class="line">//--stat可以显示统计信息，包括几个文件被修改，被添加，被提交。</div><div class="line">git log --stat、</div><div class="line">//可以指定输出格式，有oneline,short,full,fuller</div><div class="line">git log --pretty=xxx</div></pre></td></tr></table></figure><p>查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; </div><div class="line">--before=&quot;2008-11-01&quot; --no-merges</div></pre></td></tr></table></figure></p><h3 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h3><p>有时候提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit --amend</div></pre></td></tr></table></figure></p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &apos;initial commit&apos;</div><div class="line">$ git add forgotten_file</div><div class="line">$ git commit --amend</div></pre></td></tr></table></figure></p><p>如果文件之前提交提交过了，但这时候的修改还没提交，可以使用<br><code>git commit -am &quot;message&quot;</code><br>而不用先 <code>git add</code></p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset head &lt;file&gt;</div></pre></td></tr></table></figure></p><h3 id="撤消对文件的修改-工作区）"><a href="#撤消对文件的修改-工作区）" class="headerlink" title="撤消对文件的修改(工作区）"></a>撤消对文件的修改(工作区）</h3><p>git checkout – file<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">    modified:   CONTRIBUTING.md</div></pre></td></tr></table></figure></p><p>按照提示可以：<br><code>git checkout -- CONTRIBUTING.md</code></p><p>Git 中任何 已提交的 东西几乎总是可以恢复</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//显示远程仓库的简写及URL</div><div class="line">git remote -v</div><div class="line"></div><div class="line">git remote add 简写 url</div></pre></td></tr></table></figure><p>从远程仓库中抓取与拉取:</p><p><code>$ git fetch [remote-name]</code></p><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。注意它不会自动合并或修改你当前的工作。需要手动合并。</p><p><code>git pull</code>  命令可以自动的抓取然后合并远程分支到当前分支。</p><p>默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支。运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支</p><p>推送到远程仓库</p><p><code>git push [remote-name] [branch-name]</code></p><p>将本地分支推送到远程分支（名字不同）</p><p><code>git push [remote-name] [local-branch-name]:[remote-branch-name]</code></p><p>查看远程仓库(具体信息）<br>`git remote show [remote-name]</p><p>修改一个远程仓库的简写名<br><code>git remote rename oldname newname</code></p><p>删除远程仓库<br><code>git remote rm [remote-name]</code></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>查看标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -l &apos;v1.8.5*&apos;</div></pre></td></tr></table></figure></p><p>创建标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git tag -a v1.4 -m &apos;my version 1.4&apos;</div><div class="line">//查看具体信息</div><div class="line">git show v1.4</div><div class="line">//创建轻量级标签，不用使用-a等参数。</div><div class="line">git tag v1.4-lw</div><div class="line">//为过去的提交打上标签。后面是校验和</div><div class="line">git tag -a v1.2 9fceb02</div></pre></td></tr></table></figure></p><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后必须显式地推送标签到共享服务器上。<br><code>git push origin [tagname]</code><br>把全部标签推上去：<br><code>git push origin --tags</code></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p><code>git config --global alias.unstage &#39;reset HEAD --&#39;</code></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>创建分支：</p><p><code>git branch branch-name</code></p><p>查看各个分支所指向的对像</p><p><code>git log --oneline --decorate</code></p><p>查看每一个分支的最后一次提交：</p><p><code>git branch -v</code><br>–merged 与 –no-merged 这两个选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支</p><p><code>git branch --merged</code></p><p>切换分支</p><p><code>git checkout branch-name</code></p><p>新建分支并切换<br><code>git checkout -b branch-name</code></p><p>删除分支<br><code>git branch -d branch-name</code></p><p>合并分支：<br><code>git merge branch-name</code></p><p>如果合并分支的时候有冲突，则需要你手动解决。解决后可以使用<code>git add</code>将因为冲突而unmerge的文件标记为解决冲突。。然后手动提交。如果没有冲突，合并的时候git会自动为我们创建一个新的提交。</p><p>将远程分支合并到当前所在的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git merge origin/[remote-branch-name]</div><div class="line">//检出远程分支并切换到检出的分支</div><div class="line">git checkout -b [local-branch-name] origin/[remote-branch-name]</div><div class="line">//不修改名字，直接用远程分支的名字。检出后会跟踪远程分支</div><div class="line">git checkout --track origin/[remote-branch-name]</div></pre></td></tr></table></figure></p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者修改正在跟踪的上游分支。可以用参数-u或者–set-upstream-to<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -u origin/[remote-branch-name]</div></pre></td></tr></table></figure></p><p>查看设置的所有跟踪分支，可以使用<br><code>git branch -vv</code></p><p>删除远程分支<br><code>git push origin --delete [remote-branch-name]</code><br>git pull与git fetch的区别：前者拉取数据后自动合并，后者虚手动合并。</p><h3 id="设置https获取数据时不用输入密码"><a href="#设置https获取数据时不用输入密码" class="headerlink" title="设置https获取数据时不用输入密码"></a>设置https获取数据时不用输入密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//将凭据在内存中进行短时间的缓存</div><div class="line">git config –global credential.helper cache –file=.git_credentails. （当前项目有效）</div><div class="line">//将凭据储存在磁盘中，指定凭据存储文件的位置</div><div class="line">git config –global credential.helper store –file=git_credentails</div></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>变基：在一个分支上提取修改和补丁在另一个分支的基础上运用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line">//或者用一条命令,不用先切换到experiment分支</div><div class="line">git rebase master experiment</div></pre></td></tr></table></figure></p><p>执行完变基之后再合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge experiment</div></pre></td></tr></table></figure></p><p>整个提交历史就会变成一条直线，很简洁。</p><p>–onto 选项：<br>选中在 client 分支里但不在 server 分支里的修改,将它们在 master 分支上重演：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase --onto master server client</div></pre></td></tr></table></figure></p><p><img src="http://wiki.jikexueyuan.com/project/pro-git-two/images/43.png" alt="变基"></p><p>  用变基解决变基问题：<br>  如果团队中的某人强制推送并覆盖了一些你所基于的提交（使用变基），你可以使用变基来解决这个问题。可以先fetch下来被覆盖过的更新，再将你手头的工作基于此进行变基，<code>git rebase remote/master</code><br>  或者直接使用 <code>git pull --rebase</code></p><p>  总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git特点&quot;&gt;&lt;a href=&quot;#git特点&quot; class=&quot;headerlink&quot; title=&quot;git特点&quot;&gt;&lt;/a&gt;git特点&lt;/h3&gt;&lt;p&gt;直接记录快照，而非差异比较。每次提交更新，主要对当时的全部文件制作一个快照并保存这个快照的索引。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centos7搭建svn服务</title>
    <link href="http://yoursite.com/2017/11/21/centos7%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2017/11/21/centos7搭建svn服务/</id>
    <published>2017-11-21T15:58:41.000Z</published>
    <updated>2017-11-21T15:59:35.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>CentOS通过yum安装subversion。</p><p>$ sudo yum install subversion<br> subversion安装在/bin目录：</p><p>$ which svnserve<br>usr/bin/svnserve<br>检查一下subversion是否安装成功。</p><p><code>$ svnserve --version</code></p><h3 id="建立版本库"><a href="#建立版本库" class="headerlink" title="建立版本库"></a>建立版本库</h3><p>subversion默认以/var/svn作为数据根目录，可以通过/etc/sysconfig/svnserve修改这个默认位置。</p><p>使用svnadmin建立版本库hello-svn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir -p /opt/svn</div><div class="line">$ sudo svnadmin create /opt/svn/hello-svn</div></pre></td></tr></table></figure><p>###配置<br>编辑用户文件passwd，新增两个用户：admin和guest。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat /opt/svn/hello-svn/conf/passwd </div><div class="line">[users]</div><div class="line">admin = admin</div><div class="line">guest = guest</div></pre></td></tr></table></figure><p>编辑权限文件authz，用户admin设置可读写权限，guest设置只读权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat /opt/svn/hello-svn/conf/authz </div><div class="line">[/]</div><div class="line">admin = rw</div><div class="line">guest = r</div></pre></td></tr></table></figure></p><p>编辑svnserve.conf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cat /opt/svn/hello-svn/conf/svnserve.conf </div><div class="line">[general]</div><div class="line">anon-access = none                     #控制非鉴权用户访问版本库的权限</div><div class="line">auth-access = write                    #控制鉴权用户访问版本库的权限</div><div class="line">password-db = passwd                   #指定用户名口令文件名</div><div class="line">authz-db = authz                       #指定权限配置文件名</div><div class="line">realm = spring-hello-world             #指定版本库的认证域，即在登录时提示的认证域名称</div></pre></td></tr></table></figure></p><h3 id="SVN服务"><a href="#SVN服务" class="headerlink" title="SVN服务"></a>SVN服务</h3><p>启动SVN服务。</p><p><code>$ sudo systemctl start svnserve.service</code><br>检查服务是否启动成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep svn</div><div class="line">root      16349  0.0  0.1 162180   900 ?        Ss   15:01   0:00 /usr/bin/svnserve --daemon --pid-file=/run/svnserve/svnserve.pid -r /opt/svn</div></pre></td></tr></table></figure></p><p>通过netstat可以看到SVN打开了3690端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo netstat -tnlp</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </div><div class="line">tcp        0      0 0.0.0.0:3690            0.0.0.0:*               LISTEN      16349/svnserve</div></pre></td></tr></table></figure></p><p>设置成开机启动。</p><p><code>$ sudo systemctl enable svnserve.service</code></p><ol><li>客户端测试<br>客户端可以通过TortoriseSVN测试。注意url前缀为svn。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;CentOS通过yum安装subversion。&lt;/p&gt;
&lt;p&gt;$ sudo yum install subversion&lt;br&gt; subv
      
    
    </summary>
    
      <category term="svn" scheme="http://yoursite.com/categories/svn/"/>
    
    
      <category term="svn" scheme="http://yoursite.com/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>桶式排序与基数排序</title>
    <link href="http://yoursite.com/2017/11/21/%E6%A1%B6%E5%BC%8F%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/11/21/桶式排序与基数排序/</id>
    <published>2017-11-21T15:57:06.000Z</published>
    <updated>2017-11-21T15:58:19.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的基本思想是：对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。<br>所以可以直接把 arr[i] 放到它输出数组中的位置上。假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。</p><p>算法流程：<br>待排序数组 int[] arr = new int[]{4,3,6,3,5,1};<br>辅助计数数组 int[] help = new int[max - min + 1]; //该数组大小为待排序数组中的最大值减最小值+1<br>输出数组 int[] res = new int[arr.length];</p><p>1.求出待排序数组的最大值max=6， 最小值min=1<br>2.实例化辅助计数数组help，help数组中每个下标对应arr中的一个元素，help用来记录每个元素出现的次数<br>3.计算 arr 中每个元素在help中的位置 position = arr[i] - min，此时 help = [1,0,2,1,1,1]; （3出现了两次，2未出现）<br>4.根据 help 数组求得排序后的数组，此时 res = [1,3,3,4,5,6]</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public static int[] countSort(int[] arr)&#123;</div><div class="line">    if (arr == null || arr.length == 0) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int max = Integer.MIN_VALUE;</div><div class="line">    int min = Integer.MAX_VALUE;</div><div class="line">    </div><div class="line">    //找出数组中的最大最小值</div><div class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</div><div class="line">        max = Math.max(max, arr[i]);</div><div class="line">        min = Math.min(min, arr[i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int help[] = new int[max];</div><div class="line">    </div><div class="line">    //找出每个数字出现的次数</div><div class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</div><div class="line">        int mapPos = arr[i] - min;</div><div class="line">        help[mapPos]++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int index = 0;</div><div class="line">    for(int i = 0; i &lt; help.length; i++)&#123;</div><div class="line">        while(help[i]-- &gt; 0)&#123;</div><div class="line">            arr[index++] = i+min;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h3><p>桶排序可用于最大最小值相差较大的数据情况，比如[9012,19702,39867,68957,83556,102456]。<br>但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><p>桶排序的基本思想是：把数组 arr 划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并。<br>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值max、最小值min<br>2.我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1<br>3.遍历数组 arr，计算每个元素 arr[i] 放的桶<br>4.每个桶各自排序<br>5.遍历桶数组，把排序好的元素放进输出数组</p><p>java代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public static void bucketSort(int[] arr)&#123;</div><div class="line">    </div><div class="line">    int max = Integer.MIN_VALUE;</div><div class="line">    int min = Integer.MAX_VALUE;</div><div class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</div><div class="line">        max = Math.max(max, arr[i]);</div><div class="line">        min = Math.min(min, arr[i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //桶数</div><div class="line">    int bucketNum = (max - min) / arr.length + 1;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);</div><div class="line">    for(int i = 0; i &lt; bucketNum; i++)&#123;</div><div class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //将每个元素放入桶</div><div class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</div><div class="line">        int num = (arr[i] - min) / (arr.length);</div><div class="line">        bucketArr.get(num).add(arr[i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //对每个桶进行排序</div><div class="line">    for(int i = 0; i &lt; bucketArr.size(); i++)&#123;</div><div class="line">        Collections.sort(bucketArr.get(i));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    System.out.println(bucketArr.toString());</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基于桶式排序，将要排序的数字一位一位的比较，经历多次桶式排序，得出最终的序列</p><p>如果要排序的元素可以分成多位，并且每一位都在一个固定的范围内，则可以用这种排序方法，如对10进制数字的排序。按低位到高位的数字进行桶排序。</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//基数排序函数</div><div class="line">//a表示要排序的数组</div><div class="line">//d表示每一位数字的范围（这里是10进制数，有0~9一共10种情况）</div><div class="line">public static void sort(int[] a,int d)&#123;</div><div class="line">//n用来表示当前排序的是第几位</div><div class="line">int n = 1;</div><div class="line">//hasNum用来表示数组中是否有至少一个数字存在第n位</div><div class="line">boolean hasNum = false;</div><div class="line">//二维数组temp用来保存当前排序的数字</div><div class="line">//第一维d表示一共有d个桶</div><div class="line">//第二维a.length表示每个桶最多可能存放a.length个数字</div><div class="line">int[][] temp = new int[d][a.length];</div><div class="line">int[] order = new int[d];</div><div class="line">while(true)&#123;</div><div class="line">//判断是否所有元素均无比更高位，因为第一遍一定要先排序一次，所以有n!=1的判断</div><div class="line">if(n != 1 &amp;&amp; !hasNum)&#123;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">hasNum = false;</div><div class="line">//遍历要排序的数组，将其存入temp数组中（按照第n位上的数字将数字放入桶中）</div><div class="line">for(int i = 0;i &lt; a.length;i++)&#123;</div><div class="line">int x = a[i]/(n*10);</div><div class="line">if(x != 0)&#123;</div><div class="line">hasNum = true;</div><div class="line">&#125;</div><div class="line">int lsd = (x%10);</div><div class="line">temp[lsd][order[lsd]] = a[i];</div><div class="line">order[lsd]++;</div><div class="line">&#125;</div><div class="line">//k用来将排序好的temp数组存入data数组（将桶中的数字倒出）</div><div class="line">int k = 0;</div><div class="line">for(int i = 0;i &lt; d;i++)&#123;</div><div class="line">if(order[i] != 0)&#123;</div><div class="line">for(int j = 0;j &lt; order[i];j++)&#123;</div><div class="line">a[k] = temp[i][j];</div><div class="line">k++;</div><div class="line">&#125;    </div><div class="line">&#125;</div><div class="line">order[i] = 0;</div><div class="line">&#125;</div><div class="line">n++;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计数排序&quot;&gt;&lt;a href=&quot;#计数排序&quot; class=&quot;headerlink&quot; title=&quot;计数排序&quot;&gt;&lt;/a&gt;计数排序&lt;/h3&gt;&lt;p&gt;计数排序的基本思想是：对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。&lt;br&gt;所以可以直接把 arr[i
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>快速排序及其优化</title>
    <link href="http://yoursite.com/2017/11/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/11/20/快速排序及其优化/</id>
    <published>2017-11-20T15:42:36.000Z</published>
    <updated>2017-11-20T15:45:38.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比基准点小，另一部分比基准点大。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”</li><li>分割操作：把该基准放在序列中的实际位置，即最终排序完成后该基准所在的位置。此时序列将分成两个子序列。在基准左边的元素都比该基准小，在基准右边的元素都比基准大.</li><li>递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</li></ol><p>程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static void quicksort(int[] arr,int n)&#123;</div><div class="line">quicksort(arr,0,n-1);</div><div class="line">&#125;</div><div class="line">//递归调用快速排序</div><div class="line">private static void quicksort(int[] arr,int l,int r)&#123;</div><div class="line">if(l&gt;=r) return;</div><div class="line">int p = partition(arr, l, r);</div><div class="line">quicksort(arr, l,p-1);</div><div class="line">quicksort(arr, p+1,r);</div><div class="line">&#125;</div><div class="line">public static int partition(int[] arr,int l,int r)&#123;</div><div class="line">int v = arr[l];</div><div class="line">// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</div><div class="line">int i=l+1,j=r;</div><div class="line">while(true)&#123;</div><div class="line">while(i&lt;=r &amp;&amp; arr[i]&lt;v) i++;</div><div class="line">while(j&gt;=l+1 &amp;&amp; arr[j]&gt;v) j--;</div><div class="line">if(i&gt;j) break;</div><div class="line">swap(arr, i, j);</div><div class="line">i++;</div><div class="line">j--;</div><div class="line">&#125;</div><div class="line">swap(arr,l,j);</div><div class="line">return j;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="选择基准的方式"><a href="#选择基准的方式" class="headerlink" title="选择基准的方式"></a>选择基准的方式</h3><ol><li>取序列的第一个或最后一个元素作为基准。但是这种方式不好。因为当序列已经有序时，每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为Θ(n^2)。</li><li>随机选取基准。在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴。但在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。</li><li>三数取中。对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。但是还是处理不了重复数组的问题。</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>当待排序序列的长度分割到一定大小后(5-20），使用插入排序。原因：对于很小和部分有序的数组，快排不如插排好。</li><li>在一次分割结束后，可以把与基准相等的元素聚在一起，继续下次分割时，不用再对这些元素分割。<br>程序如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//使用三路快速排序，避免重复元素过多而导致时间复杂度为O(2^n)的情况</div><div class="line">public static void quicksort3way(int[] arr, int l,int r)&#123;</div><div class="line">if(l&gt;=r) return;</div><div class="line">//当排序的数目较小时使用插入排序可提高性能</div><div class="line">if(r-l &lt;= 15)&#123;</div><div class="line">InsertSort.insertSort(arr, l,r);</div><div class="line">&#125;</div><div class="line">//随机选取基准,避免数组近乎有序而导致时间复杂度为O(2^n)的情况</div><div class="line">int temp = random.nextInt(r-l+1)+l;</div><div class="line">SortUtil.swap(arr, l, temp);</div><div class="line"></div><div class="line">int v = arr[l];</div><div class="line">int lt = l; //arr[l+1...lt]&lt;v</div><div class="line">int gt = r+1;//arr[gt...r]&gt;v</div><div class="line">int i = l+1;//arr[lt+1..i)==v</div><div class="line"></div><div class="line">while(i&lt;gt)&#123;</div><div class="line">if(arr[i]&lt;v)&#123;</div><div class="line">SortUtil.swap(arr,i,lt+1);</div><div class="line">i++;</div><div class="line">lt++;</div><div class="line">&#125;else if(arr[i]&gt;v)&#123;</div><div class="line">SortUtil.swap(arr,i,gt-1);</div><div class="line">gt--;</div><div class="line">&#125;else&#123;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">SortUtil.swap(arr,l,lt);</div><div class="line">quicksort3way(arr,l,lt-1);</div><div class="line">quicksort3way(arr,gt,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void quicksort3(int[] arr,int n)&#123;</div><div class="line">quicksort3way(arr,0,n-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h3&gt;&lt;p&gt;快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比基准点小，另一部分比基准点大。之后分别
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序优化</title>
    <link href="http://yoursite.com/2017/11/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/11/20/冒泡排序优化/</id>
    <published>2017-11-20T15:40:48.000Z</published>
    <updated>2017-11-20T15:42:17.454Z</updated>
    
    <content type="html"><![CDATA[<ol><li>设一个交换标志flag.先令flag=0,如果每一趟排序有出现交换，则令flag=1.如果没有发生交换则表示排序完毕。</li><li>考虑这种情况，假如有100个数字，前10个无序，后90个有序。后面90个数字不用交换。可以记录每趟排序最后交换的数字n。下一趟排序从0到n排序。</li></ol><p>综合起来写出如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static void sort(int[] arr,int n)&#123;</div><div class="line">int flag = n;</div><div class="line">while(flag &gt;0)&#123;</div><div class="line">int k = flag;</div><div class="line">flag = 0;</div><div class="line">for(int i=1;i&lt;k;i++)&#123;</div><div class="line">if(arr[i]&lt;arr[i-1])&#123;</div><div class="line">int temp = arr[i];</div><div class="line">arr[i] = arr[i-1];</div><div class="line">arr[i-1] = temp;</div><div class="line">flag = i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//测试代码</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">int[] arr = new int[]&#123;49, 38, 65, 97, 26, 13, 27, 49, 55, 4&#125;;</div><div class="line">sort(arr,arr.length);</div><div class="line">for(int a:arr)&#123;</div><div class="line">System.out.print(a+&quot;,&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;设一个交换标志flag.先令flag=0,如果每一趟排序有出现交换，则令flag=1.如果没有发生交换则表示排序完毕。&lt;/li&gt;
&lt;li&gt;考虑这种情况，假如有100个数字，前10个无序，后90个有序。后面90个数字不用交换。可以记录每趟排序最后交换的数字n。下一
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>maven常用插件（jetty测试，cargo自动部署)</title>
    <link href="http://yoursite.com/2017/11/18/maven%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%EF%BC%88jetty%E6%B5%8B%E8%AF%95%EF%BC%8Ccargo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2017/11/18/maven常用插件（jetty测试，cargo自动部署/</id>
    <published>2017-11-17T16:22:54.000Z</published>
    <updated>2017-11-17T16:24:22.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用jetty-maven-plugin插件进行测试"><a href="#使用jetty-maven-plugin插件进行测试" class="headerlink" title="使用jetty-maven-plugin插件进行测试"></a>使用jetty-maven-plugin插件进行测试</h3><p>当修改源码时无需重启项目，此插件能够检测编译后的文件变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;  </div><div class="line">            &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;7.6.10.v20130312&lt;/version&gt;  </div><div class="line">            &lt;configuration&gt;  </div><div class="line">                &lt;scanIntervalSecond&gt;10&lt;/scanIntervalSecond&gt;  </div><div class="line">                &lt;webApp&gt;  </div><div class="line">                    &lt;contextPath&gt;/test&lt;/contextPath&gt;  </div><div class="line">                &lt;/webApp&gt;  </div><div class="line">                &lt;connectors&gt;  </div><div class="line">                    &lt;connector implementation=&quot;org.eclipse.jetty.server.nio.SelectChannelConnector&quot;&gt;  </div><div class="line">                        &lt;port&gt;8787&lt;/port&gt;  </div><div class="line">                        &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;  </div><div class="line">                    &lt;/connector&gt;  </div><div class="line">                &lt;/connectors&gt;  </div><div class="line">            &lt;/configuration&gt;  </div><div class="line">        &lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>这里扫描项目变更的时间间隔为10秒，默认为0表述不扫描。</p><p>默认情况下，只有org.apache.maven.plugins和org.codehuas.mojo两个groupId下的插件才支持简化的命令行调用。所以需要在settings.xml中配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt;</div></pre></td></tr></table></figure></p><p>也可以在命令行指定端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn jetty:run -Djetty.port=9999</div></pre></td></tr></table></figure></p><h3 id="使用cargo实现自动化部署"><a href="#使用cargo实现自动化部署" class="headerlink" title="使用cargo实现自动化部署"></a>使用cargo实现自动化部署</h3><p>部署到本地Web容器：<br>在standalone模式，Cargo会从Web容器的安装目录复制一份配置到用户指定的目录，然后在此基础上部署应用，每次重新构建的时候，这个目录都会被清空，所有配置被重新生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;  </div><div class="line">    &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt;  </div><div class="line">    &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt;  </div><div class="line">    &lt;version&gt;1.4.9&lt;/version&gt;  </div><div class="line">    &lt;configuration&gt;  </div><div class="line">        &lt;container&gt;  </div><div class="line">            &lt;containerId&gt;tomcat7x&lt;/containerId&gt;  </div><div class="line">            &lt;home&gt;/usr/local/devtools/apache-tomcat-7.0.55&lt;/home&gt;  </div><div class="line">        &lt;/container&gt;  </div><div class="line">        &lt;configuration&gt;  </div><div class="line">            &lt;type&gt;standalone&lt;/type&gt;  </div><div class="line">            &lt;home&gt;$&#123;project.build.directory&#125;/tomcat7x&lt;/home&gt;  </div><div class="line">            &lt;properties&gt;  </div><div class="line">                &lt;!-- 更改监听端口 --&gt;  </div><div class="line">                &lt;cargo.servlet.port&gt;8088&lt;/cargo.servlet.port&gt;  </div><div class="line">            &lt;/properties&gt;  </div><div class="line">        &lt;/configuration&gt;  </div><div class="line">    &lt;/configuration&gt;  </div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>然后用mvn cargo:start启动<br>在existing模式下，用户需要指定现有的web容器配置目录，然后Cargo会直接使用这些配置并将应用部署到其对应的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;  </div><div class="line">    &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt;  </div><div class="line">    &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt;  </div><div class="line">    &lt;version&gt;1.4.9&lt;/version&gt;  </div><div class="line">    &lt;configuration&gt;  </div><div class="line">        &lt;container&gt;  </div><div class="line">            &lt;containerId&gt;tomcat7x&lt;/containerId&gt;  </div><div class="line">            &lt;home&gt;/usr/local/devtools/apache-tomcat-7.0.55&lt;/home&gt;  </div><div class="line">        &lt;/container&gt;  </div><div class="line">        &lt;configuration&gt;  </div><div class="line">            &lt;type&gt;existing&lt;/type&gt;  </div><div class="line">            &lt;home&gt;/usr/local/devtools/apache-tomcat-7.0.55&lt;/home&gt;  </div><div class="line">        &lt;/configuration&gt;  </div><div class="line">    &lt;/configuration&gt;  </div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>部署到远程服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;  </div><div class="line">            &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt;  </div><div class="line">            &lt;artifactId&gt;cargo-maven2-plugin&lt;/artifactId&gt;  </div><div class="line">            &lt;version&gt;1.4.9&lt;/version&gt;  </div><div class="line">            &lt;configuration&gt;  </div><div class="line">                &lt;container&gt;  </div><div class="line">                    &lt;containerId&gt;tomcat7x&lt;/containerId&gt;  </div><div class="line">                    &lt;type&gt;remote&lt;/type&gt;  </div><div class="line">                &lt;/container&gt;  </div><div class="line">                &lt;configuration&gt;  </div><div class="line">                    &lt;type&gt;runtime&lt;/type&gt;  </div><div class="line">                    &lt;properties&gt;  </div><div class="line">                        &lt;cargo.remote.uri&gt;http://10.64.204.188:8080/manager&lt;/cargo.remote.uri&gt;  </div><div class="line">                        &lt;cargo.remote.username&gt;admin&lt;/cargo.remote.username&gt;  </div><div class="line">                        &lt;cargo.remote.password&gt;password&lt;/cargo.remote.password&gt;  </div><div class="line">                    &lt;/properties&gt;  </div><div class="line">                &lt;/configuration&gt;  </div><div class="line">            &lt;/configuration&gt;  </div><div class="line">        &lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>需在在tomcat的tomcat-user.xml添加用户名和角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;  </div><div class="line">&lt;role rolename=&quot;manager-script&quot;/&gt;  </div><div class="line">&lt;role rolename=&quot;manager-jmx&quot;/&gt;    </div><div class="line">&lt;role rolename=&quot;manager-status&quot;/&gt;  </div><div class="line">&lt;role rolename=&quot;admin-gui&quot;/&gt;  </div><div class="line">&lt;user username=&quot;admin&quot; password=&quot;password&quot; roles=&quot;admin-gui,manager-gui,manager-script,manager-status&quot;/&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用jetty-maven-plugin插件进行测试&quot;&gt;&lt;a href=&quot;#使用jetty-maven-plugin插件进行测试&quot; class=&quot;headerlink&quot; title=&quot;使用jetty-maven-plugin插件进行测试&quot;&gt;&lt;/a&gt;使用jetty-
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>编写maven插件</title>
    <link href="http://yoursite.com/2017/11/18/%E7%BC%96%E5%86%99maven%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/11/18/编写maven插件/</id>
    <published>2017-11-17T16:18:21.000Z</published>
    <updated>2017-11-17T16:19:35.393Z</updated>
    
    <content type="html"><![CDATA[<p>新建一个项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate</div><div class="line">然后选择maven-archetype-plugin(number为1073）</div></pre></td></tr></table></figure></p><p>生成项目骨架，然后倒入IDE中。</p><p>maven插件项目的POM有两个特殊的地方：</p><ol><li>packaging必须为maven-plugin。</li><li>包含一个maven-plugin-api的依赖。该依赖包含了插件开发所必须的类。例如AbstractMojo.version建议与maven版本保持一致，都为3.0</li></ol><h3 id="为插件编写目标"><a href="#为插件编写目标" class="headerlink" title="为插件编写目标"></a>为插件编写目标</h3><p>每个插件目标类都必须继承AbstractMojo并实现execute方法。只有这样maven才能识别该插件目标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @goal count</div><div class="line"> */</div><div class="line">public class CountMojo extends AbstractMojo &#123;</div><div class="line"></div><div class="line"></div><div class="line">    private static final String[] INCLUDES_DEFAULT = &#123;&quot;java&quot;,&quot;xml&quot;,&quot;properties&quot;&#125;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @parameter expression=&quot;$&#123;project.basedir&#125;&quot;</div><div class="line">     * @required</div><div class="line">     * @readonly</div><div class="line">     */</div><div class="line">    private File basedir;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @parameter expression=&quot;$&#123;project.build.sourceDirectory&#125;&quot;</div><div class="line">     * @required</div><div class="line">     * @readonly</div><div class="line">     */</div><div class="line">    private File sourceDirectory;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @parameter expression=&quot;$&#123;project.build.testSourceDiretory&#125;&quot;</div><div class="line">     * @readonly</div><div class="line">     */</div><div class="line">    private File testSourceDirectory;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @parameter expression=&quot;$&#123;project.build.resources&#125;&quot;</div><div class="line">     * @readonly</div><div class="line">     */</div><div class="line">    private List&lt;Resource&gt; resources;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @parameter expression=&quot;$&#123;project.build.testSource&#125;&quot;</div><div class="line">     * @readonly</div><div class="line">     */</div><div class="line">    private List&lt;Resource&gt; testResources;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @parameter</div><div class="line">     */</div><div class="line">    private String[] includes;</div><div class="line"></div><div class="line">    public void execute()throws  MojoExecutionException,MojoFailureException &#123;</div><div class="line">        if(includes == null &amp;&amp; includes.length == 0 )&#123;</div><div class="line">            includes = INCLUDES_DEFAULT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            countDir(sourceDirectory);</div><div class="line">            countDir(testSourceDirectory);</div><div class="line">            for(Resource resource : resources)&#123;</div><div class="line">                countDir(new File(resource.getDirectory()));</div><div class="line">            &#125;</div><div class="line">            for(Resource resource : testResources)&#123;</div><div class="line">                countDir(new File(resource.getDirectory()));</div><div class="line">            &#125;</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            throw new MojoExecutionException(&quot;unable to count lines of code. &quot;,e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void countDir(File dir) throws IOException&#123;</div><div class="line">        if(dir == null || !dir.exists())&#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        List&lt;File&gt; collected = new ArrayList&lt;File&gt;();</div><div class="line">        collectFiles(collected,dir);</div><div class="line">        int lines = 0;</div><div class="line"></div><div class="line">        for(File sourceFile : collected)&#123;</div><div class="line">            lines += countLine(sourceFile);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String path = dir.getAbsolutePath().substring(basedir.getAbsolutePath().length());</div><div class="line"></div><div class="line">        getLog().info(path + &quot;:&quot; + lines + &quot; lines of code in &quot;+ collected.size()+&quot; files&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    //收集文件</div><div class="line">    private void collectFiles(List&lt;File&gt; collected,File file)&#123;</div><div class="line">        if(file.isFile())&#123;</div><div class="line">            for(String include : includes)&#123;</div><div class="line">                if(file.getName().endsWith(&quot;.&quot;+include))&#123;</div><div class="line">                    collected.add(file);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">            for(File sub : file.listFiles())&#123;</div><div class="line">                collectFiles(collected,sub);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //计算每个文件的行数</div><div class="line">    private  int countLine(File file) throws IOException&#123;</div><div class="line">        BufferedReader reader = new BufferedReader(new FileReader(file));</div><div class="line"></div><div class="line">        int line = 0;</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            while (reader.ready())&#123;</div><div class="line">                reader.readLine();</div><div class="line">                line++;</div><div class="line">            &#125;</div><div class="line">        &#125;finally &#123;</div><div class="line">            reader.close();</div><div class="line">        &#125;</div><div class="line">        return line;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面该插件的类是统计资源文件的代码行数。Mojo类采用java1.4风格的标注（将注解卸载注释中），其中@goal表示自己的目标名称。有了目标名称才能在项目中配置该插件目标，或者在命令行调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn com.loserbird:mymvnplugin:1.0-SNAPSHOT:count</div></pre></td></tr></table></figure></p><h3 id="配置插件属性"><a href="#配置插件属性" class="headerlink" title="配置插件属性"></a>配置插件属性</h3><p>includes属性使用了@parameter参数，所以可以配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">           &lt;groupId&gt;com.loserbird&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;mymvnplugin&lt;/artifactId&gt;</div><div class="line">           &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">           &lt;configuration&gt;</div><div class="line">               &lt;includes&gt;</div><div class="line">                   &lt;include&gt;java&lt;/include&gt;</div><div class="line">                   &lt;include&gt;sql&lt;/include&gt;</div><div class="line">               &lt;/includes&gt;</div><div class="line">           &lt;/configuration&gt;</div><div class="line">       &lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>使用mvn clean install 将插件项目安装到本地之后，就能使用它统计maven项目的代码行了。</p><p>如果想简化命令调用，可以将该插件的groupId添加到settings的pluginGroups中。然后maven命令就可以简化为<br><code>mvn mymvnplugin:count</code></p><h3 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h3><ul><li>@goal:目标</li><li>@phase:默认将该目标绑定至Default生命周期的某个阶段。</li><li>@requireDependencyResolution (scope):在运行Mojo之前必须解析所有指定范围的依赖。默认runtime</li><li>@requiresDirectInvocation：默认为false.如果true则表示只能在命令行调用。</li><li>@requiresReport:是否要求项目报告已经生成。默认false.</li><li>@aggregator:当Mojo在多模块项目上运行时，使用该标注表示该目标只会在顶层模块运行。</li><li>@execute goal=””:在运行该目标之前先让maven运行另外一个目标。</li><li>@execute phase=””:在运行该目标之前先让maven运行一个并行的生命周期，到指定的阶段为止。</li><li>@execute lifecycle=”” phase=”” :在运行该目标之前先让maven运行一个自定义的生命周期，到指定的阶段为止。</li></ul><h3 id="mojo参数"><a href="#mojo参数" class="headerlink" title="mojo参数"></a>mojo参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@parameter alias=&quot;&quot; :在pom配置的时候就可以配置为别名。</div><div class="line">@parameter expression=&quot;$&#123;systemProperty&#125;&quot;:使用系统属性表达式对mojo参数进行赋值。用户可以在命令行配置该mojo参数（-D）。</div></pre></td></tr></table></figure><h3 id="错误处理和日志"><a href="#错误处理和日志" class="headerlink" title="错误处理和日志"></a>错误处理和日志</h3><ul><li>抛出MojoExecutionException异常表示未预期的异常，maven提示BUILD ERROR</li><li>抛出MojoFailureException异常表示预期的异常，maven提示BUILD FAIL。</li></ul><p>AbstractMojo提供了一个getLog()方法，可以打一些日志。有debug,info,warn,error级别。</p><h3 id="测试maven插件"><a href="#测试maven插件" class="headerlink" title="测试maven插件"></a>测试maven插件</h3><p>maven社区有个用来帮助插件继承测试的插件：maven-invoker-pluign.该插件能够在一组项目上执行maven,并检查每个项目的构建是否成功。<br>在插件项目的pom中配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt;</div><div class="line">             &lt;plugin&gt;</div><div class="line">                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">                 &lt;artifactId&gt;maven-invoker-plugin&lt;/artifactId&gt;</div><div class="line">                 &lt;version&gt;1.7&lt;/version&gt;</div><div class="line">                 &lt;configuration&gt;</div><div class="line">                     &lt;projectsDirectory&gt;src/it&lt;/projectsDirectory&gt;</div><div class="line">                     &lt;goals&gt;</div><div class="line">                         &lt;goal&gt;clean&lt;/goal&gt;</div><div class="line">                         &lt;goal&gt;test-compile&lt;/goal&gt;</div><div class="line">                     &lt;/goals&gt;</div><div class="line">                     &lt;debug&gt;true&lt;/debug&gt;</div><div class="line">                     &lt;postBuildHookScript&gt;verify.groovy&lt;/postBuildHookScript&gt;</div><div class="line">                 &lt;/configuration&gt;</div><div class="line">                 &lt;executions&gt;</div><div class="line">                     &lt;execution&gt;</div><div class="line">                         &lt;id&gt;integration-test&lt;/id&gt;</div><div class="line">                         &lt;goals&gt;</div><div class="line">                             &lt;goal&gt;install&lt;/goal&gt;</div><div class="line">                             &lt;goal&gt;run&lt;/goal&gt;</div><div class="line">                         &lt;/goals&gt;</div><div class="line">                     &lt;/execution&gt;</div><div class="line">                 &lt;/executions&gt;</div><div class="line">             &lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>projectDirectory用来配置测试项目的目录。goals表示在测试项目要运行的Maven目标。postBuildHookScript表示在测试完成后要运行的验证脚本。</p><p>maven-invoker-plugin有两个目标install,run绑定到integration-test阶段，install表示将插件构件安装到本地。run目标执行定义好的mvn命令并运行验证脚本。 </p><p>接下来在测试项目上配置使用插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">       &lt;groupId&gt;com.loserbird&lt;/groupId&gt;</div><div class="line">       &lt;artifactId&gt;mymvnplugin&lt;/artifactId&gt;</div><div class="line">       &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">       &lt;executions&gt;</div><div class="line">         &lt;execution&gt;</div><div class="line">           &lt;phase&gt;verify&lt;/phase&gt;</div><div class="line">           &lt;goals&gt;</div><div class="line">             &lt;goal&gt;count&lt;/goal&gt;</div><div class="line">           &lt;/goals&gt;</div><div class="line">         &lt;/execution&gt;</div><div class="line">       &lt;/executions&gt;</div><div class="line">     &lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>验证脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def file = new File( basedir, &quot;build.log&quot; );</div><div class="line"></div><div class="line">def countMain = false;</div><div class="line">def countTest = false;</div><div class="line"></div><div class="line">file.eachLine&#123;</div><div class="line">    if(it=~/src.main.java:13 lines of code in 1 files/)</div><div class="line">        countMain = true</div><div class="line">    if(it=~/src.main.java:13 lines of code in 1 files/)</div><div class="line">        countTest = true</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(!countMain)</div><div class="line">    throw new RuntimeException(&quot;incorrect src/main/java count info&quot;)</div><div class="line">if(!countTest)</div><div class="line">    throw new RuntimeException(&quot;incorrect src/test/java count info&quot;)</div></pre></td></tr></table></figure></p><p>在插件项目上执行mvn clean install就能看到对应的输出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新建一个项目：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/t
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>编写Archetype</title>
    <link href="http://yoursite.com/2017/11/18/%E7%BC%96%E5%86%99Archetype/"/>
    <id>http://yoursite.com/2017/11/18/编写Archetype/</id>
    <published>2017-11-17T16:16:32.000Z</published>
    <updated>2017-11-17T16:19:27.640Z</updated>
    
    <content type="html"><![CDATA[<p>Archetype就是项目的模板，用来生成项目的骨架。他也是通过插件来实现的。该插件就是maven-archetype-plugin。</p><h3 id="批处理方式使用archetype"><a href="#批处理方式使用archetype" class="headerlink" title="批处理方式使用archetype"></a>批处理方式使用archetype</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate</div><div class="line">-DinteractiveMode=false</div><div class="line">-DarchetypeGroupId=xxx.xx</div><div class="line">-DarchetypeArtifactId= xxx.xx</div><div class="line">-DarchetypeVersion=xx</div><div class="line">-DgroupId=xx</div><div class="line">-DartifactId=xx</div><div class="line">-Dversion=xx</div></pre></td></tr></table></figure><h3 id="编写Archetype"><a href="#编写Archetype" class="headerlink" title="编写Archetype"></a>编写Archetype</h3><p>创建一个属于自己的Archetype.一个典型的Archetype Maven项目主要包括以下部分：</p><ul><li>pom.xml</li><li>src/main/resources/archetype-resources/pom.xml:基于该Archetype生成的项目的原型</li><li>src/main/resources/META-INF/maven/archetype-metadata.xml:Archetype的描述符文件</li><li>src/main/resource/archetype-resources/**:其它需要包含在Archetype的内容。</li></ul><h3 id="为archetype构件创建一个新工程和pom-xml"><a href="#为archetype构件创建一个新工程和pom-xml" class="headerlink" title="为archetype构件创建一个新工程和pom.xml"></a>为archetype构件创建一个新工程和pom.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"> </div><div class="line">  &lt;groupId&gt;my.groupId&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;my-archetype-id&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure><p>你需要修改的仅仅是groupId, artifactId 和 version。这三个参数在后面从命令行调用archetype:generate是会用到。</p><h3 id="创建archetype描述符"><a href="#创建archetype描述符" class="headerlink" title="创建archetype描述符"></a>创建archetype描述符</h3><p>Archetype插件V1.0.x文件用metadata.xml描述符来描述。。Archetype插件V2.0.x是一个完全支持V1.0.x的新一代插件，并且它会添加一个新的原型描述符（它保存在archetype-metadata.xml文件中），它更加灵活，并提供更多的功能，但本质上与之前的版本是相同的。<br>方案一：使用archetype.xml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;archetype xmlns=&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">           xsi:schemaLocation=&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype/1.0.0 http://maven.apache.org/xsd/archetype-1.0.0.xsd&quot;&gt;</div><div class="line">    &lt;id&gt;archetypeSample&lt;/id&gt;</div><div class="line">    &lt;sources&gt;</div><div class="line">        &lt;source&gt;src/main/java/Application.java&lt;/source&gt;</div><div class="line">    &lt;/sources&gt;</div><div class="line">    &lt;testSources&gt;</div><div class="line">        &lt;source&gt;src/test/java/ApplicationTest.java&lt;/source&gt;</div><div class="line">    &lt;/testSources&gt;</div><div class="line">&lt;/archetype&gt;</div></pre></td></tr></table></figure></p><p>方案二：使用archetype-metadata.xml文件描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div><div class="line">&lt;archetype-description name=&quot;sample&quot;&gt;</div><div class="line">    &lt;fileSets&gt;</div><div class="line">        &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot;&gt;</div><div class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</div><div class="line">            &lt;includes&gt;</div><div class="line">                &lt;include&gt;**/*.java&lt;/include&gt;</div><div class="line">            &lt;/includes&gt;</div><div class="line">        &lt;/fileSet&gt;</div><div class="line">        &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot;&gt;</div><div class="line">            &lt;directory&gt;src/main/test&lt;/directory&gt;</div><div class="line">            &lt;includes&gt;</div><div class="line">                &lt;include&gt;**/*.java&lt;/include&gt;</div><div class="line">            &lt;/includes&gt;</div><div class="line">        &lt;/fileSet&gt;</div><div class="line">        &lt;fileSet filtered=&quot;true&quot; packaged=&quot;false&quot;&gt;</div><div class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</div><div class="line">            &lt;includes&gt;</div><div class="line">                &lt;include&gt;**/*.properties&lt;/include&gt;</div><div class="line">            &lt;/includes&gt;</div><div class="line">        &lt;/fileSet&gt;</div><div class="line">    &lt;/fileSets&gt;</div><div class="line">    &lt;requiredProperties&gt;</div><div class="line">        &lt;requiredProperty key=&quot;groupId&quot;&gt;</div><div class="line">            &lt;defaultValue&gt;com.loserbird&lt;/defaultValue&gt;</div><div class="line">        &lt;/requiredProperty&gt;</div><div class="line">    &lt;/requiredProperties&gt;</div><div class="line">&lt;/archetype-description&gt;</div></pre></td></tr></table></figure></p><p>其中filtered表示是否使用属性过滤。</p><h3 id="创建原型文件和原型pom-xml"><a href="#创建原型文件和原型pom-xml" class="headerlink" title="创建原型文件和原型pom.xml"></a>创建原型文件和原型pom.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"> </div><div class="line">  &lt;groupId&gt;$&#123;groupId&#125;&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;$&#123;artifactId&#125;&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</div><div class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"> </div><div class="line">  &lt;name&gt;A custom project&lt;/name&gt;</div><div class="line">  &lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</div><div class="line">      &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">  &lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure><p>项目目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">archetype</div><div class="line">|-- pom.xml</div><div class="line">`-- src</div><div class="line">    `-- main</div><div class="line">        `-- resources</div><div class="line">            |-- META-INF</div><div class="line">            |   `-- maven</div><div class="line">            |       `--archetype.xml</div><div class="line">            `-- archetype-resources</div><div class="line">                |-- pom.xml</div><div class="line">                `-- src</div><div class="line">                    |-- main</div><div class="line">                    |   `-- java</div><div class="line">                    |       `-- Application.java</div><div class="line">                    `-- test</div><div class="line">                        `-- java</div><div class="line">                            `-- ApplicationTest.java</div></pre></td></tr></table></figure></p><p>执行mvn install安装到本地，然后就可以用这个archetype创建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate -DinteractiveMode=false</div><div class="line">-DarchetypeGroupId=com.loserbird -DarchetypeArtifactId=archetypeSample -DarchetypeVersion=1.0-SNAPSHOT -DgroupId=com.loserbird -DartifactId=custompro -Dversion=1.0-SNAPSHOT</div><div class="line">-Dpackage=com.loserbird</div></pre></td></tr></table></figure></p><h3 id="Archetype-Catalog"><a href="#Archetype-Catalog" class="headerlink" title="Archetype Catalog"></a>Archetype Catalog</h3><p>如何把自己写的archetype添加到archetype列表中？而不用指定那么长的坐标。</p><p>这个列表的信息来源于archetype-catalog.xml文件。</p><p>maven-archetype-plugin可以从以下位置读取archetype-catalog.xml文件：</p><ul><li>internal:maven-archetype-plugin内置的Archetype Catalog.</li><li>local:指向本地用户的Archetype Catalog,位置为~/.m2/archetype-catalog.xml.默认不存在。</li><li>remote:指向maven中央仓库的Archetype Catalog。</li><li>file://…:用户可以指定本机任何位置。</li><li><a href="http://..:使用http协议指定远程的文件。" target="_blank" rel="external">http://..:使用http协议指定远程的文件。</a></li></ul><p>也可以在命令行调用的时候指定<br><code>mvn archetype:generate -DarchetypeCatalog=&quot;&quot;</code></p><p>maven-archetype-plugin 2.0-beta-4之前的版本，archetypeCatalog默认值为“internal,local”,从maven-archetype-plugin2.0-beta-5开始，默认值变为“remote local”</p><h3 id="生成本地仓库的Archetype-Catalog"><a href="#生成本地仓库的Archetype-Catalog" class="headerlink" title="生成本地仓库的Archetype Catalog"></a>生成本地仓库的Archetype Catalog</h3><p>maven-archetype-plugin提供了一个名为crawl的目标，可以用它来遍历本地Maven仓库的内容并自动生成archetype-catalog.xml文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn archetype:crawl</div></pre></td></tr></table></figure></p><h3 id="使用nexus-archetype-plugin"><a href="#使用nexus-archetype-plugin" class="headerlink" title="使用nexus-archetype-plugin"></a>使用nexus-archetype-plugin</h3><p>该插件能够基于Nexus仓库索引实时地生成archetype-catalog.xml文件。由于是基于索引生成所以速度非常快。</p><p>将该插件的bundle.zip包解压到Nexus工作目录sonatype-work/nexus/下的plugin-repository/子目录下，然后重启nexus,插件就安装完成了。就能够在参控股库的根目录下看到archetype-catalog.xml文件。下载即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Archetype就是项目的模板，用来生成项目的骨架。他也是通过插件来实现的。该插件就是maven-archetype-plugin。&lt;/p&gt;
&lt;h3 id=&quot;批处理方式使用archetype&quot;&gt;&lt;a href=&quot;#批处理方式使用archetype&quot; class=&quot;head
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven属性、profile和资源过滤</title>
    <link href="http://yoursite.com/2017/11/14/Maven%E5%B1%9E%E6%80%A7%E3%80%81profile%E5%92%8C%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/"/>
    <id>http://yoursite.com/2017/11/14/Maven属性、profile和资源过滤/</id>
    <published>2017-11-14T04:56:38.000Z</published>
    <updated>2017-11-14T04:57:40.140Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Maven的六类属性"><a href="#Maven的六类属性" class="headerlink" title="Maven的六类属性"></a>Maven的六类属性</h3><ul><li>主要有两个常用内置属性：<code>${basedir}</code>项目的根目录(包含pom.xml文件的目录)，<code>${version}</code>项目版本</li><li><p>POM属性:<br>　用户可以使用该属性引用POM文件中对应元素的值，常用的POM属性包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　　　　　$&#123;project.build.sourceDirectory&#125;：项目的主源码目录，默认为src/main/java</div><div class="line"></div><div class="line">　　　　　　$&#123;project.build.testSourceDirectory&#125;：项目的测试源码目录，默认为src/test/java</div><div class="line"></div><div class="line">　　　　　　$&#123;project.build.directory&#125;：项目构件输出目录，默认为target/</div><div class="line"></div><div class="line">　　　　　　$&#123;project.outputDirectory&#125;：项目主代码编译输出目录，默认为target/classes/</div></pre></td></tr></table></figure></li><li><p>自定义属性:用户可以在POM的<properties>元素下自定义Maven属性</properties></p></li><li><p>Settings属性:用户使用settings.开头的属性引用settings.xml文件中XML元素的值</p></li><li><p>Java系统属性:<br>所有Java系统属性都可以使用Maven属性引用</p></li><li><p>环境变量属性:<br>所有环境变量都可以使用以env.开头的Maven属性引用</p><h3 id="资源过滤"><a href="#资源过滤" class="headerlink" title="资源过滤"></a>资源过滤</h3><p>为了应对环境的变化，需要使用maven属性将会发生变化的部分提取出来。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">database.jdbc.driverClass=$&#123;db.driver&#125;</div><div class="line">database.jdbc.connectionURL=&#123;db.url&#125;</div><div class="line">database.jdbc.username=&#123;db.username&#125;</div><div class="line">database.jdbc.password=&#123;db.password&#125;</div></pre></td></tr></table></figure></li></ul><p>在pom的profile定义属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;profiles&gt;</div><div class="line">       &lt;profile&gt;</div><div class="line">           &lt;id&gt;dev&lt;/id&gt;</div><div class="line">           &lt;properties&gt;</div><div class="line">               &lt;db.driver&gt;com.mysql.jdbc.Driver&lt;/db.driver&gt;</div><div class="line">               &lt;db.url&gt;jdbc:mysql://localhost/test&lt;/db.url&gt;</div><div class="line">               &lt;db.username&gt;dev&lt;/db.username&gt;</div><div class="line">               &lt;db.password&gt;dev-pwd&lt;/db.password&gt;</div><div class="line">           &lt;/properties&gt;</div><div class="line">       &lt;/profile&gt;</div><div class="line">   &lt;/profiles&gt;</div></pre></td></tr></table></figure></p><p>如何让maven解析资源文件的maven属性？</p><p>maven-resources-plugin默认的行为只是将资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。只需开启资源过滤maven就能够解析资源文件的maven属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">          &lt;resource&gt;</div><div class="line">              &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</div><div class="line">              &lt;filtering&gt;true&lt;/filtering&gt;</div><div class="line">          &lt;/resource&gt;</div><div class="line">      &lt;/resources&gt;</div><div class="line">      &lt;testResources&gt;</div><div class="line">          &lt;testResource&gt;</div><div class="line">              &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt;</div><div class="line">              &lt;filtering&gt;true&lt;/filtering&gt;</div><div class="line">          &lt;/testResource&gt;</div><div class="line">      &lt;/testResources&gt;</div></pre></td></tr></table></figure></p><p>在命令行调用时激活profile。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -Pdev</div></pre></td></tr></table></figure></p><h3 id="激活profile"><a href="#激活profile" class="headerlink" title="激活profile"></a>激活profile</h3><ol><li><p>命令行激活:<br>用户可以使用mvn命令行参数-P加上profile的id来激活profile，多个id之间以逗号分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　mvn clean install -Pdev-x, dev-y</div></pre></td></tr></table></figure></li><li><p>settings文件显式激活:<br>用户希望某个profile默认一直处于激活的状态，可以配置settings.xml文件的activeProfiles元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;settings&gt;</div><div class="line"></div><div class="line">    &lt;activeProfiles&gt;</div><div class="line">        &lt;activeProfile&gt;dev-x&lt;/activeProfile&gt;</div><div class="line">    &lt;/activeProfiles&gt;</div><div class="line"></div><div class="line">&lt;/settings&gt;</div></pre></td></tr></table></figure></li><li><p>系统属性激活<br>用户可以配置当某系统属性存在的时候，自动激活profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;profiles&gt; </div><div class="line">    &lt;profile&gt;</div><div class="line">        &lt;activation&gt;</div><div class="line">            &lt;property&gt;</div><div class="line">                &lt;name&gt;test&lt;/name&gt;　</div><div class="line">　　　　　　　　　 &lt;value&gt;x&lt;/value&gt;　//当值为x的时候激活profile</div><div class="line">            &lt;/property&gt;</div><div class="line">        &lt;/activation&gt;</div><div class="line">    &lt;/profile&gt;</div><div class="line">&lt;/profiles&gt;</div></pre></td></tr></table></figure></li></ol><p><code>mvn clean install -Dtest = x</code></p><ol><li><p>操作系统环境激活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;profiles&gt;</div><div class="line">    &lt;profile&gt;</div><div class="line">        &lt;activation&gt;</div><div class="line">            &lt;os&gt;</div><div class="line">                &lt;name&gt;Windows XP&lt;/name&gt;</div><div class="line">                &lt;family&gt;Windows&lt;/family&gt;</div><div class="line">                &lt;arch&gt;x86&lt;/arch&gt;</div><div class="line">                &lt;version&gt;5.1.2600&lt;/version&gt;</div><div class="line">            &lt;/os&gt;</div><div class="line">        &lt;/activation&gt;</div><div class="line">    &lt;/profile&gt;</div><div class="line">&lt;/profiles&gt;</div></pre></td></tr></table></figure></li><li><p>文件存在与否激活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;profiles&gt;</div><div class="line">    &lt;profile&gt;</div><div class="line">        &lt;activation&gt;</div><div class="line">            &lt;file&gt;</div><div class="line">                &lt;missing&gt;x.properties&lt;/missing&gt;</div><div class="line">                &lt;exists&gt;y.properties&lt;/exists&gt;</div><div class="line">            &lt;/file&gt;</div><div class="line">        &lt;/activation&gt;</div><div class="line">    &lt;/profile&gt;</div><div class="line">&lt;/profiles&gt;</div></pre></td></tr></table></figure></li><li><p>默认激活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;profiles&gt;</div><div class="line">    &lt;profile&gt;</div><div class="line">        &lt;id&gt;dev&lt;/id&gt;</div><div class="line">        &lt;activation&gt;</div><div class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</div><div class="line">        &lt;/activation&gt;</div><div class="line">    &lt;/profiles&gt;</div><div class="line">&lt;/profiles&gt;</div></pre></td></tr></table></figure></li></ol><p>pom的profile可使用maven绝大多数元素，而settings的profile可使用的元素为repositories,pluginRepositories,properties。</p><h3 id="web资源过滤"><a href="#web资源过滤" class="headerlink" title="web资源过滤"></a>web资源过滤</h3><p>需要配置maven-war-plugin对src/main/webapp这一web资源目录开启过滤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.1-beta-1&lt;/version&gt;</div><div class="line">    &lt;configuration&gt;</div><div class="line">        &lt;webResources&gt;</div><div class="line">            &lt;resource&gt;</div><div class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</div><div class="line">                &lt;directory&gt;src/main/webapp&lt;/directory&gt;</div><div class="line">                &lt;includes&gt;</div><div class="line">                    &lt;include&gt;**/*.css&lt;/include&gt;</div><div class="line">                    &lt;include&gt;**/*.js&lt;/include&gt;</div><div class="line">                &lt;/includes&gt;</div><div class="line">            &lt;/resource&gt;</div><div class="line">        &lt;/webResources&gt;</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Maven的六类属性&quot;&gt;&lt;a href=&quot;#Maven的六类属性&quot; class=&quot;headerlink&quot; title=&quot;Maven的六类属性&quot;&gt;&lt;/a&gt;Maven的六类属性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主要有两个常用内置属性：&lt;code&gt;${basedir}&lt;/co
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>使用nexus搭建私服</title>
    <link href="http://yoursite.com/2017/11/12/%E4%BD%BF%E7%94%A8nexus%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D/"/>
    <id>http://yoursite.com/2017/11/12/使用nexus搭建私服/</id>
    <published>2017-11-12T07:29:56.766Z</published>
    <updated>2017-11-12T07:30:47.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>nexus是一个maven仓库管理软件,典型的javaweb应用，安装包有两种版本，包含jetty的bundle包，或不包含web容器的war包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>下载bundle包，在bin/jsw/目录下找到nexus.bat启动（windows）即可。</li><li>如果是下载war包，把war包丢进web容器运行即可。</li></ol><h3 id="登录nexus"><a href="#登录nexus" class="headerlink" title="登录nexus"></a>登录nexus</h3><p>nexus的默认管理员和密码为：admin/admin123</p><h3 id="nexus的仓库与仓库组"><a href="#nexus的仓库与仓库组" class="headerlink" title="nexus的仓库与仓库组"></a>nexus的仓库与仓库组</h3><p>nexus的仓库有四种类型：</p><ul><li>public(仓库组）</li><li>hosted(宿主）</li><li>proxy(代理）</li><li>vitual(虚拟）</li></ul><p>每种仓库的格式为maven2或者maven1.policy(策略）为发布版本还是快照版本。</p><p>虚拟仓库的作用是动态的将仓库内容格式转换，就是为了支持maven1.</p><h3 id="仓库详解"><a href="#仓库详解" class="headerlink" title="仓库详解"></a>仓库详解</h3><ul><li>Central:代理maven中央仓库。只会下载和缓存中央仓库中的发布版本构件。</li><li>Realease:部署组织内部的发布版本构件。</li><li>Snapshots:部署组织内部的快照版本构件。</li><li>3rd party:部署无法从公共仓库获得的第三方发布版本构件。</li><li>Apache Snapshots:代理Apache maven仓库的快照版本构件。</li><li>Public Repositories:该仓库组将上述所有策略为Release的仓库聚合并通过一致的地址提供服务。</li><li>Public Snapshot Repositories:该仓库组将上述所有策略为Snapshot的仓库聚合并通过一致的地址提供服务。</li></ul><h3 id="添加各种仓库（简单）"><a href="#添加各种仓库（简单）" class="headerlink" title="添加各种仓库（简单）"></a>添加各种仓库（简单）</h3><h3 id="nexus的搜索"><a href="#nexus的搜索" class="headerlink" title="nexus的搜索"></a>nexus的搜索</h3><p>nexus通过维护仓库的索引来提供搜索功能。例如为了能够搜索中央仓库的依赖，需要设置central仓库为允许下载中央仓库的远程索引。</p><h3 id="设置maven从nexus下载构建"><a href="#设置maven从nexus下载构建" class="headerlink" title="设置maven从nexus下载构建"></a>设置maven从nexus下载构建</h3><p>在项目的pom文件中设置仓库和插件仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;repositories&gt;</div><div class="line">  &lt;repository&gt;</div><div class="line">  &lt;id&gt;nexus&lt;/id&gt;</div><div class="line">  &lt;name&gt;Nexus&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;</div><div class="line">  &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</div><div class="line">  &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</div><div class="line">  &lt;/repository&gt;</div><div class="line">  &lt;/repositories&gt;</div><div class="line">  </div><div class="line">  &lt;pluginRepositories&gt;</div><div class="line">  &lt;pluginRepository&gt;</div><div class="line">  &lt;id&gt;nexus&lt;/id&gt;</div><div class="line">  &lt;name&gt;Nexus&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;</div><div class="line">  &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</div><div class="line">  &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</div><div class="line">  &lt;/pluginRepository&gt;</div><div class="line">  &lt;/pluginRepositories&gt;</div></pre></td></tr></table></figure></p><p>只对单个项目有效。。</p><p>在settings.xml中配置（全局有效）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;profiles&gt;</div><div class="line">&lt;profile&gt;</div><div class="line">&lt;id&gt;nexus&lt;/id&gt;</div><div class="line">&lt;repositories&gt;</div><div class="line">  &lt;repository&gt;</div><div class="line">  &lt;id&gt;nexus&lt;/id&gt;</div><div class="line">  &lt;name&gt;Nexus&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;</div><div class="line">  &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</div><div class="line">  &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</div><div class="line">  &lt;/repository&gt;</div><div class="line">  &lt;/repositories&gt;</div><div class="line">  </div><div class="line">  &lt;pluginRepositories&gt;</div><div class="line">  &lt;pluginRepository&gt;</div><div class="line">  &lt;id&gt;nexus&lt;/id&gt;</div><div class="line">  &lt;name&gt;Nexus&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;</div><div class="line">  &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</div><div class="line">  &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</div><div class="line">  &lt;/pluginRepository&gt;</div><div class="line">  &lt;/pluginRepositories&gt;</div><div class="line">&lt;/profile&gt;</div><div class="line">&lt;/profiles&gt;</div><div class="line"></div><div class="line">&lt;activeProfiles&gt;</div><div class="line">    &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;</div><div class="line">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</div><div class="line">  &lt;/activeProfiles&gt;</div></pre></td></tr></table></figure></p><h3 id="配置maven只使用私服"><a href="#配置maven只使用私服" class="headerlink" title="配置maven只使用私服"></a>配置maven只使用私服</h3><p>maven除了从nexus下载构建之外，还会时不时的访问中央仓库。要让maven所有请求都请求nexus，需要配置为nexus配置镜像。镜像地址为私服的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> &lt;mirrors&gt;</div><div class="line">&lt;mirror&gt;</div><div class="line">        &lt;id&gt;nexus&lt;/id&gt;</div><div class="line">        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</div><div class="line">        &lt;name&gt;personal server&lt;/name&gt;</div><div class="line">      &lt;url&gt;http://localhost:8081/nexus/content/group/public&lt;/url&gt;</div><div class="line">&lt;/mirror&gt;</div><div class="line">&lt;/mirrors&gt;</div></pre></td></tr></table></figure></p><h3 id="使用maven部署构件至nexus"><a href="#使用maven部署构件至nexus" class="headerlink" title="使用maven部署构件至nexus"></a>使用maven部署构件至nexus</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;distributionManagement&gt;</div><div class="line">  &lt;repository&gt;</div><div class="line">  &lt;id&gt;nexus-releases&lt;/id&gt;</div><div class="line">  &lt;name&gt;Nexus-releases&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases&lt;/url&gt;</div><div class="line">  &lt;/repository&gt;</div><div class="line">  &lt;snapshotRepository&gt;</div><div class="line">  &lt;id&gt;nexus-snapshots&lt;/id&gt;</div><div class="line">  &lt;name&gt;Nexus-snapshots&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots&lt;/url&gt;</div><div class="line">  &lt;/snapshotRepository&gt;</div><div class="line">  &lt;/distributionManagement&gt;</div></pre></td></tr></table></figure><p>还需要在settings.xml中配置认证信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;servers&gt;</div><div class="line">      &lt;server&gt;</div><div class="line">      &lt;id&gt;nexus-releases&lt;/id&gt;</div><div class="line">      &lt;username&gt;admin&lt;/username&gt;</div><div class="line">      &lt;password&gt;admin123&lt;/password&gt;</div><div class="line">    &lt;/server&gt;</div><div class="line">     &lt;server&gt;</div><div class="line">      &lt;id&gt;nexus-snapshots&lt;/id&gt;</div><div class="line">      &lt;username&gt;admin&lt;/username&gt;</div><div class="line">      &lt;password&gt;admin123&lt;/password&gt;</div><div class="line">    &lt;/server&gt;</div><div class="line">&lt;/servers&gt;</div></pre></td></tr></table></figure></p><h3 id="手动部署第三方构件至nexus"><a href="#手动部署第三方构件至nexus" class="headerlink" title="手动部署第三方构件至nexus"></a>手动部署第三方构件至nexus</h3><p>可以把某些第三方的jar包通过nexus的上传界面上传到私服中。</p><p>首先选择一个宿主仓库如3rd party，然后在页面的下方选择Artifact upload选项卡。根据要求填写参数上传构件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;nexus是一个maven仓库管理软件,典型的javaweb应用，安装包有两种版本，包含jetty的bundle包，或不包含web容器的wa
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
  </entry>
  
  <entry>
    <title>maven依赖和生命周期</title>
    <link href="http://yoursite.com/2017/11/12/maven%E4%BE%9D%E8%B5%96%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2017/11/12/maven依赖和生命周期/</id>
    <published>2017-11-12T05:32:01.000Z</published>
    <updated>2017-11-12T05:33:13.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><ul><li>compile:编译，测试，运行都有效</li><li>test,进测试有效</li><li>provided:编译，测试有效，运行无效。如servlet-api.</li><li>runtime:测试和运行有效，编译主代码时无效。如JDBC驱动实现。项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行时才需要实现该接口的具体JDBC驱动。</li><li>system:与provided一样。但是必须通过systemPath元素显示的指定依赖文件的路径。此类依赖不由maven仓库解析。而与本机系统绑定。可以使用环境变量。</li><li>import:不会对三种classpath产生实际的影响。</li></ul><h3 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A-&gt;B-&gt;X(1.0)</div><div class="line">A-&gt;D-&gt;X(2.0)</div></pre></td></tr></table></figure><p>第一原则：路径最近者优先。</p><p>第二原则：pom中依赖声明的顺序</p><h3 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A-&gt;B</div><div class="line">B-&gt;X(可选)optional=true</div><div class="line">B-&gt;Y(可选)</div></pre></td></tr></table></figure><p>如果这三个依赖的范围都是compile,X,Y 依赖将不会被传递。如果A要依赖其中的一个，必须显示声明。</p><p>为什么要使用可选依赖，考虑这样一种情况：项目B实现了两个特性，其中的特性一依赖于x,特性二依赖于Y，但是这两个特性是互斥的，用户不可能同时使用这两个特性。所以需要项目A去显示的声明决定。</p><p>建议不要使用可选依赖，因为符合单一职责原则。</p><h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><p>使用<exclusions>元素排除</exclusions></p><h3 id="中央仓库定位"><a href="#中央仓库定位" class="headerlink" title="中央仓库定位"></a>中央仓库定位</h3><p>在$M2_HOME/lib/maven-model-builder-3.0.jar中有个pom-4.0.0.xml。里面定义了中央仓库及其url.这个文件是所有maven项目都会继承的超级POM。</p><h3 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h3><p>默认的远程仓库无法满足项目需求时，可能需要的构件存在另外一个远程仓库中，这时可以在pom中配置给仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;repositories&gt;</div><div class="line">       &lt;repository&gt;</div><div class="line">           &lt;id&gt;jboss&lt;/id&gt;</div><div class="line">           &lt;name&gt;jboss repository&lt;/name&gt;</div><div class="line">           &lt;url&gt;http://reposiroty.jboss.com/maven2&lt;/url&gt;</div><div class="line">           &lt;releases&gt;</div><div class="line">               &lt;enabled&gt;true&lt;/enabled&gt;</div><div class="line">               &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;</div><div class="line">               &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt;</div><div class="line">           &lt;/releases&gt;</div><div class="line">           &lt;snapshots&gt;</div><div class="line">               &lt;enabled&gt;false&lt;/enabled&gt;</div><div class="line">           &lt;/snapshots&gt;</div><div class="line">            &lt;layout&gt;default&lt;/layout&gt;</div><div class="line">       &lt;/repository&gt;</div><div class="line">   &lt;/repositories&gt;</div></pre></td></tr></table></figure></p><p>updatePolicy设置maven从远程仓库检查更新的频率，默认为daily(每天检查一次），还有可选的值：never,always(每次构建都检查更新），interval:x(每隔x分钟)</p><p>checksumPolicy配置检查检验和文件的策略。当构件被部署到远程仓库时，会同时部署对应的校验和文件。如果校验失败，就会触发相应的策略。默认为warn.其它的值还有ignore,fail。</p><h3 id="远程仓库认证"><a href="#远程仓库认证" class="headerlink" title="远程仓库认证"></a>远程仓库认证</h3><p>当远程仓库需要认证才能访问时需要在settings.xml中配置认证信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;servers&gt;</div><div class="line">&lt;server&gt;</div><div class="line">      &lt;id&gt;deploymentRepo&lt;/id&gt;</div><div class="line">      &lt;username&gt;repouser&lt;/username&gt;</div><div class="line">      &lt;password&gt;repopwd&lt;/password&gt;</div><div class="line">    &lt;/server&gt;</div><div class="line">&lt;/servers&gt;</div></pre></td></tr></table></figure></p><h3 id="部署至远程仓库"><a href="#部署至远程仓库" class="headerlink" title="部署至远程仓库"></a>部署至远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!--定义snapshots库和releases库的nexus地址--&gt;  </div><div class="line">   &lt;distributionManagement&gt;  </div><div class="line">       &lt;repository&gt;  </div><div class="line">           &lt;id&gt;nexus-releases&lt;/id&gt;  </div><div class="line">           &lt;url&gt;  </div><div class="line">               http://172.17.103.59:8081/nexus/content/repositories/releases/  </div><div class="line">           &lt;/url&gt;  </div><div class="line">       &lt;/repository&gt;  </div><div class="line">       &lt;snapshotRepository&gt;  </div><div class="line">           &lt;id&gt;nexus-snapshots&lt;/id&gt;  </div><div class="line">           &lt;url&gt;  </div><div class="line">               http://172.17.103.59:8081/nexus/content/repositories/snapshots/  </div><div class="line">           &lt;/url&gt;  </div><div class="line">       &lt;/snapshotRepository&gt;  </div><div class="line">   &lt;/distributionManagement&gt;</div></pre></td></tr></table></figure><p>执行mvn clean deploy就可以部署了。</p><h3 id="maven的快照版本机制"><a href="#maven的快照版本机制" class="headerlink" title="maven的快照版本机制"></a>maven的快照版本机制</h3><p>当把快照版本的机制发到仓库中，maven会自动 为构件打上时间戳。，有了该时间戳，maven就能随时找到仓库中该构件最新的文件。</p><p>用户可以在命令行中加入-U参数强制检查更新。当maven检查完更新策略，并决定检查依赖更新的时候，就需要价差仓库元数据maven-metadata.xml</p><h3 id="从仓库解析依赖的机制"><a href="#从仓库解析依赖的机制" class="headerlink" title="从仓库解析依赖的机制"></a>从仓库解析依赖的机制</h3><ol><li>当依赖的范围是system的时候，maven直接从本地文件系统解析构件。</li><li>根据依赖坐标计算仓库路径后，尝试直接从本地仓库寻找构件，如果发现相应构件则解析成功。</li><li>在本地仓库不存在相应的构件的情况下，如果依赖的版本是显示的发布版本构件，如1.2，1.2-beta-1等，则遍历所有的远程仓库，发现后，下载并解析使用。</li><li>如果依赖的版本是RELEASE或者LATEST，则基于更新策略读取所有远程仓库的元数据groupId/artifactId/maven-metadata.xml,将其与本地仓库的对应元数据合并后，计算出RELEASE或者LATEST真实的值，然后基于这个真实的值检查本地和远程仓库，如步骤2,3.</li><li>如果依赖的版本是SNAPSHOT，基于更新策略读取所有远程仓库的元数据groupId/artifactId/version/maven-metadata.xml，将其与本地仓库的对应元数据合并后，得到最新快照版本的值，然后基于该值检查本地仓库，或者从远程仓库下载。</li><li>如果最后解析得到的构件版本是时间戳格式的快照，如1.4.1-20091104.121450-121，则复制其时间戳格式的文件至非时间戳格式，如SNAPSHOT，并使用该非时间戳格式的构件。</li></ol><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>如果仓库X可以提供仓库Y存储的所有内容，那么可以认为X是Y的一个镜像。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;mirror&gt;</div><div class="line">       &lt;id&gt;maven.net.cn&lt;/id&gt;</div><div class="line">       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</div><div class="line">       &lt;name&gt;one of the central mirrors in china&lt;/name&gt;</div><div class="line">     &lt;url&gt;http://maven.net.cn/content/groups/public&lt;/url&gt;</div><div class="line">&lt;/mirror&gt;</div></pre></td></tr></table></figure></p><p>mirrorOf表示配置为哪个仓库的镜像。可以把私服设置为所有仓库的镜像。即把mirrorOf的值设为*号。</p><h3 id="三套生命周期"><a href="#三套生命周期" class="headerlink" title="三套生命周期"></a>三套生命周期</h3><ol><li>clean:清理项目</li><li>default:构件项目</li><li>site:生成项目站点</li></ol><p>每个生命周期都包含一些阶段，这些阶段是有顺序的。并且后面的阶段依赖于前面的阶段。三套生命周期是相互独立的。</p><h4 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h4><ol><li>pre-clean:</li><li>clean:清理上一次构建生成的文件</li><li>post-clean:</li></ol><h3 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h3><ol><li>validate</li><li>initialize</li><li>generate-sources</li><li>process-sources:处理项目主资源文件。一般来说，是对src/main/resources目录内容进行变量替换等工作，复制到项目输出的注classpath目录中。</li><li>generate-resources</li><li>process-resources</li><li>compile:编译项目的主源码。编译src/main/java目录下的文件至主classpath目录中</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources:处理项目测试资源文件。</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile:编译项目的测试代码。</li><li>process-test-classes</li><li>test:使用单元测试框架进行测试，测试代码不会被打包或部署。</li><li>prepare-package</li><li>package:接收编译好的代码，打包成可发布的格式。</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li><li>install:将包安装到maven本地仓库</li><li>deploy:将最终的包复制到远程仓库。</li></ol><h4 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h4><ol><li>pre-site:</li><li>site:生成项目站点文档</li><li>post-site</li><li>site-deploy:将生成的项目站点发布到服务器</li></ol><h3 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h3><p>插件也是一个构件，一个插件有多个插件目标，对应多个任务。</p><h3 id="插件绑定"><a href="#插件绑定" class="headerlink" title="插件绑定"></a>插件绑定</h3><p>maven的生命周期与插件相互绑定，用以完成实际的构建任务。具体而言，是生命周期的阶段与插件的目标相互绑定，已完成每个具体的构建任务。</p><h3 id="内置绑定"><a href="#内置绑定" class="headerlink" title="内置绑定"></a>内置绑定</h3><p>maven内置了很多了插件对应maven的生命周期。例如maven-clean-plugin的clean目标对应了clean生命周期的clean阶段。</p><h3 id="自定义绑定"><a href="#自定义绑定" class="headerlink" title="自定义绑定"></a>自定义绑定</h3><p>除了内置绑定以外，用户能够选择将某个插件目标绑定到生命周期的某个阶段。例如创建项目的源码jar包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">&lt;plugins&gt;</div><div class="line">&lt;plugin&gt;</div><div class="line">&lt;groupId&gt;org.apache.maven&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;2.1.1&lt;/version&gt;</div><div class="line">&lt;executions&gt;</div><div class="line">&lt;execution&gt;</div><div class="line">&lt;id&gt;attach-srouces&lt;/id&gt;</div><div class="line">&lt;phase&gt;verify&lt;/phase&gt;</div><div class="line">&lt;goals&gt;</div><div class="line">&lt;goal&gt;jar-no-fork&lt;/goal&gt;</div><div class="line">&lt;/goals&gt;</div><div class="line">&lt;/execution&gt;</div><div class="line">&lt;/executions&gt;</div><div class="line">&lt;/plugin&gt;</div><div class="line">&lt;/plugins&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></p><h3 id="插件仓库"><a href="#插件仓库" class="headerlink" title="插件仓库"></a>插件仓库</h3><ol><li>当maven需要的插件在本地仓库不存在时，它就不会去依赖远程仓库查找，而是去插件远程仓库查找。</li><li>插件的远程仓库使用pluginRepositories和pluginRepository配置。</li><li>maven在超级pom中为核心插件设定了版本</li></ol><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ol><li>在父模块中配置dependencyManagement,它配置的依赖不会被子模块继承。只有子模块显示声明dependencyManagement下的依赖时，才会继承，这样可以省略配置version,scope等元素，统一版本管理。</li><li>import依赖范围只有在dependencyManagement元素下才有效。表示将目标pom的dependencyManagement配置导入并合并到当前pom的dependencyManagement元素中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependencyManagement&gt;</div><div class="line">&lt;dependencies&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;...&lt;/gourpId&gt;</div><div class="line">&lt;artifactId&gt;...&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;...&lt;/version&gt;</div><div class="line">&lt;type&gt;pom&lt;/type&gt;</div><div class="line">&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">&lt;/denpendency&gt;</div><div class="line">&lt;/dependencies&gt;</div><div class="line">&lt;/dependencyManagement&gt;</div></pre></td></tr></table></figure></li></ol><h3 id="maven聚合与继承"><a href="#maven聚合与继承" class="headerlink" title="maven聚合与继承"></a>maven聚合与继承</h3><p>聚合主要是为了方便快速的构建项目，而继承主要是为了消除重复配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;依赖范围&quot;&gt;&lt;a href=&quot;#依赖范围&quot; class=&quot;headerlink&quot; title=&quot;依赖范围&quot;&gt;&lt;/a&gt;依赖范围&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;compile:编译，测试，运行都有效&lt;/li&gt;
&lt;li&gt;test,进测试有效&lt;/li&gt;
&lt;li&gt;provide
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>maven打包技巧</title>
    <link href="http://yoursite.com/2017/11/10/maven%E6%89%93%E5%8C%85%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/11/10/maven打包技巧/</id>
    <published>2017-11-10T05:13:55.000Z</published>
    <updated>2017-11-12T10:52:19.147Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>中央仓库：<br><code>http://repo1.maven.org/maven2</code></p><p>由于历史原因，maven的compile插件默认只支持编译java1.3,因此需要配置该插件使其支持java5.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt;</div><div class="line">     &lt;plugin&gt;</div><div class="line">       &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">       &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">       &lt;configuration&gt;</div><div class="line">         &lt;source&gt;1.5&lt;/source&gt;</div><div class="line">         &lt;target&gt;1.5&lt;/target&gt;</div><div class="line">       &lt;/configuration&gt;</div><div class="line">     &lt;/plugin&gt;</div><div class="line">   &lt;/plugins&gt;</div></pre></td></tr></table></figure></p><p>surefire是maven中负责执行测试的插件。surefire:test任务运行测试。</p><h3 id="生成可执行jar"><a href="#生成可执行jar" class="headerlink" title="生成可执行jar"></a>生成可执行jar</h3><p>默认打包生成的jar是不能执行的。可以利用利用插件maven shade plugin来配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;  </div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  </div><div class="line">    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;  </div><div class="line">    &lt;version&gt;1.2.1&lt;/version&gt;  </div><div class="line">    &lt;executions&gt;  </div><div class="line">        &lt;execution&gt;  </div><div class="line">            &lt;phase&gt;package&lt;/phase&gt;  </div><div class="line">            &lt;goals&gt;  </div><div class="line">                &lt;goal&gt;shade&lt;/goal&gt;  </div><div class="line">            &lt;/goals&gt;  </div><div class="line">            &lt;configuration&gt;  </div><div class="line">                &lt;transformers&gt;  </div><div class="line">                    &lt;transformer  </div><div class="line">                        implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;  </div><div class="line">                        &lt;mainClass&gt;com.chenzhou.examples.Main&lt;/mainClass&gt;  </div><div class="line">                    &lt;/transformer&gt;</div><div class="line">                &lt;/transformers&gt;  </div><div class="line">            &lt;/configuration&gt;  </div><div class="line">        &lt;/execution&gt;  </div><div class="line">    &lt;/executions&gt;  </div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>项目打包时会将main-class的信息放到jar包里的MAINFEST.MF中。在target目录下会生成两个jar包。一个是可运行jar，一个是原始jar.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar xxx.jar</div></pre></td></tr></table></figure></p><h3 id="使用Archetype生成项目骨架"><a href="#使用Archetype生成项目骨架" class="headerlink" title="使用Archetype生成项目骨架"></a>使用Archetype生成项目骨架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate</div></pre></td></tr></table></figure><h3 id="dependency-中的-classifier属性"><a href="#dependency-中的-classifier属性" class="headerlink" title="dependency 中的 classifier属性"></a>dependency 中的 classifier属性</h3><p>classifier元素用来帮助定义构件输出的一些附属构件。附属构件与主构件对应，比如主构件是 kimi-app-2.0.0.jar 该项目可能还会通过使用一些插件生成 如 kimi-app-2.0.0-javadoc.jar 、 kimi-app-2.0.0-sources.jar 这样两个附属构件。这时候，javadoc,sources就是这两个附属构件的classifier,这样附属构件也就拥有了自己唯一的坐标。</p><p>不能直接定义项目的 classifer,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的。</p><p>classifier的用途在于:</p><ol><li>maven download  javadoc / sources jar包的时候</li><li>引入依赖的时候,有些jar包提供了不同jdk版本的jar包，例如json-lib。这时要定义classifier<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;json-lib&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;2.4&lt;/version&gt;</div><div class="line">            &lt;classifier&gt;jdk15&lt;/classifier&gt; </div><div class="line">        &lt;/dependency&gt;</div></pre></td></tr></table></figure></li></ol><h3 id="为项目生成源码包和javadoc"><a href="#为项目生成源码包和javadoc" class="headerlink" title="为项目生成源码包和javadoc"></a>为项目生成源码包和javadoc</h3><p>使用插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;  </div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  </div><div class="line">    &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;  </div><div class="line">    &lt;version&gt;2.1.2&lt;/version&gt;  </div><div class="line">    &lt;executions&gt;  </div><div class="line">      &lt;execution&gt;  </div><div class="line">        &lt;id&gt;attach-sources&lt;/id&gt;  </div><div class="line">        &lt;phase&gt;package&lt;/phase&gt;  </div><div class="line">        &lt;goals&gt;  </div><div class="line">          &lt;goal&gt;jar-no-fork&lt;/goal&gt;  </div><div class="line">        &lt;/goals&gt;  </div><div class="line">      &lt;/execution&gt;  </div><div class="line">    &lt;/executions&gt;  </div><div class="line">  &lt;/plugin&gt;  </div><div class="line">  </div><div class="line">  &lt;plugin&gt;            </div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  </div><div class="line">    &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;  </div><div class="line">    &lt;version&gt;2.7&lt;/version&gt;  </div><div class="line">    &lt;executions&gt;  </div><div class="line">      &lt;execution&gt;  </div><div class="line">        &lt;id&gt;attach-javadocs&lt;/id&gt;  </div><div class="line">          &lt;goals&gt;  </div><div class="line">            &lt;goal&gt;jar&lt;/goal&gt;  </div><div class="line">          &lt;/goals&gt;  </div><div class="line">      &lt;/execution&gt;  </div><div class="line">    &lt;/executions&gt;  </div><div class="line">  &lt;/plugin&gt;</div></pre></td></tr></table></figure></p><h3 id="重用测试代码"><a href="#重用测试代码" class="headerlink" title="重用测试代码"></a>重用测试代码</h3><p>如果需要重用测试代码，可以将测试代码打包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">           &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</div><div class="line">           &lt;version&gt;2.2&lt;/version&gt;</div><div class="line">           &lt;executions&gt;</div><div class="line">               &lt;execution&gt;</div><div class="line">                   &lt;goals&gt;</div><div class="line">                       &lt;goal&gt;test-jar&lt;/goal&gt;</div><div class="line">                   &lt;/goals&gt;</div><div class="line">               &lt;/execution&gt;</div><div class="line">           &lt;/executions&gt;</div><div class="line">       &lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>这个插件有两个目标，分别是jar和test-jar。前者通过maven的内置绑定在default生命周期的package阶段运行。其行为就是对项目主代码进行打包。而后者没有内置绑定，所以需要显示声明。test-jar默认绑定生命周期为package.</p><p>依赖测试构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">     &lt;groupId&gt;xxxx&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;xxx&lt;/artifactId&gt;</div><div class="line">     &lt;type&gt;test-jar&lt;/type&gt;</div><div class="line">     &lt;version&gt;xxx&lt;/version&gt;</div><div class="line">     &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">   &lt;/dependency&gt;</div></pre></td></tr></table></figure></p><p>注意type为test-jar。</p><h3 id="自定义打包格式"><a href="#自定义打包格式" class="headerlink" title="自定义打包格式"></a>自定义打包格式</h3><p>实际的软件项目常常会有更复杂的打包需求，例如我们可能需要为客户提供一份产品的分发包，这个包不仅仅包含项目的字节码文件，还得包含依赖以及相关脚本文件以方便客户解压后就能运行，此外分发包还得包含一些必要的文档。这时项目的源码目录结构大致是这样的：<br>pom.xml<br>src/main/java/<br>src/main/resources/<br>src/test/java/<br>src/test/resources/<br>src/main/scripts/<br>src/main/assembly/<br>README.txt</p><p>src/main/assembly/会包含一个打包描述文件assembly.xml<br>我们希望最终生成一个zip格式的分发包，它包含如下的一个结构：<br>bin/<br>lib/<br>README.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;assembly&gt;  </div><div class="line">  &lt;id&gt;bin&lt;/id&gt;  </div><div class="line">  &lt;formats&gt;  </div><div class="line">    &lt;format&gt;zip&lt;/format&gt;  </div><div class="line">  &lt;/formats&gt;  </div><div class="line">  &lt;dependencySets&gt;  </div><div class="line">    &lt;dependencySet&gt;  </div><div class="line">      &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt;  </div><div class="line">      &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;  </div><div class="line">    &lt;/dependencySet&gt;  </div><div class="line">  &lt;/dependencySets&gt;  </div><div class="line">  &lt;fileSets&gt;  </div><div class="line">    &lt;fileSet&gt;  </div><div class="line">      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;  </div><div class="line">      &lt;includes&gt;  </div><div class="line">        &lt;include&gt;README.txt&lt;/include&gt;  </div><div class="line">      &lt;/includes&gt;  </div><div class="line">    &lt;/fileSet&gt;  </div><div class="line">    &lt;fileSet&gt;  </div><div class="line">      &lt;directory&gt;src/main/scripts&lt;/directory&gt;  </div><div class="line">      &lt;outputDirectory&gt;/bin&lt;/outputDirectory&gt;  </div><div class="line">      &lt;includes&gt;  </div><div class="line">        &lt;include&gt;run.sh&lt;/include&gt;  </div><div class="line">        &lt;include&gt;run.bat&lt;/include&gt;  </div><div class="line">      &lt;/includes&gt;  </div><div class="line">    &lt;/fileSet&gt;  </div><div class="line">  &lt;/fileSets&gt;  </div><div class="line">&lt;/assembly&gt;</div></pre></td></tr></table></figure></p><ul><li>首先这个assembly.xml文件的id对应了其最终生成文件的classifier。</li><li>其次formats定义打包生成的文件格式，这里是zip。因此结合id我们会得到一个名为hello-world-1.0-bin.zip的文件。（假设artifactId为hello-world，version为1.0）</li><li>dependencySets用来定义选择依赖并定义最终打包到什么目录，这里我们声明的一个depenencySet默认包含所有所有 依赖，而useProjectArtifact表示将项目本身生成的构件也包含在内，最终打包至输出包内的lib路径下（由 outputDirectory指定）。</li><li>fileSets允许用户通过文件或目录的粒度来控制打包。这里的第一个fileSet打包README.txt文件至包的根目录下，第二个fileSet则将src/main/scripts下的run.sh和run.bat文件打包至输出包的bin目录下</li></ul><p>最后，我们需要配置maven-assembly-plugin使用打包描述文件，并绑定生命周期阶段使其自动执行打包操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;  </div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  </div><div class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;  </div><div class="line">    &lt;version&gt;2.2.1&lt;/version&gt;  </div><div class="line">    &lt;configuration&gt;  </div><div class="line">      &lt;descriptors&gt;  </div><div class="line">        &lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt;  </div><div class="line">      &lt;/descriptors&gt;  </div><div class="line">    &lt;/configuration&gt;  </div><div class="line">    &lt;executions&gt;  </div><div class="line">      &lt;execution&gt;  </div><div class="line">        &lt;id&gt;make-assembly&lt;/id&gt;  </div><div class="line">        &lt;phase&gt;package&lt;/phase&gt;  </div><div class="line">        &lt;goals&gt;  </div><div class="line">          &lt;goal&gt;single&lt;/goal&gt;  </div><div class="line">        &lt;/goals&gt;  </div><div class="line">      &lt;/execution&gt;  </div><div class="line">    &lt;/executions&gt;  </div><div class="line">  &lt;/plugin&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;p&gt;中央仓库：&lt;br&gt;&lt;code&gt;http://repo1.maven.org/maven2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于历
      
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>线程池详解</title>
    <link href="http://yoursite.com/2017/10/24/03/"/>
    <id>http://yoursite.com/2017/10/24/03/</id>
    <published>2017-10-24T10:14:08.000Z</published>
    <updated>2017-10-25T12:06:56.016Z</updated>
    
    <content type="html"><![CDATA[<p>Executor接口：顶级接口。只有一个方法：</p><blockquote><p>execute(Runnable command)</p></blockquote><p>ThreadPoolExecutor类实现类这个接口，任何Runnable的对象都可以被ThreadPoolExecutor线程池调度。</p><p>通过Executors工厂类可以创建线程池：</p><ul><li>newFixedThreadPool(int nThreads):返回一个固定线程数量的线程池。当有一个新的任务提交时，若有空闲线程则立刻执行，否则将暂存在一个任务队列中，带有线程空闲时再处理。</li><li>new CachedThreadPool():返回一个可根据实际情况调整线程数量的线程池。数量不确定，但若有空闲线程可以复用则优先使用，若没有则会创建新的线程。</li><li>new SingleThreadExecutor():返回只有一个线程的线程池。</li><li>new ScheduledThreadPool(int corePoolSize):返回一个ScheduledExecutorService对象。</li></ul><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>ScheduledExecutorService有两个方法：</p><ul><li>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</li><li>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</li></ul><p>前者是按固定的频率周期性的执行，后者是执行完一个任务后隔一段时间再执行一个任务。</p><p>注：如果任务遇到异常，后续的子任务也会停止调度。因此必须保证异常及时被处理。</p><h3 id="核心线程池的内部实现"><a href="#核心线程池的内部实现" class="headerlink" title="核心线程池的内部实现"></a>核心线程池的内部实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor(int corePoolSize, </div><div class="line">int maximumPoolSize, </div><div class="line">long keepAliveTime, </div><div class="line">TimeUnit unit,</div><div class="line">BlockingQueue&lt;Runnable&gt; workQueue, </div><div class="line">ThreadFactory threadFactory,</div><div class="line">RejectedExecutionHandler handler)</div></pre></td></tr></table></figure><ul><li>corePoolSize:线程池中的线程数量</li><li>maximumPoolSize:线程池中的最大数量</li><li>keepAliveTime:当线程池中数量超过corePoolSize时，多余的空闲线程的存活时间。</li><li>unit:keepAliveTime的单位</li><li>workQueue:任务队列</li><li>threadFactory:线程工厂，用于创建线程。</li><li>handler:拒绝策略。当任务太多来不及处理时，如何拒绝任务。</li></ul><h3 id="可使用的BlockingQueue"><a href="#可使用的BlockingQueue" class="headerlink" title="可使用的BlockingQueue"></a>可使用的BlockingQueue</h3><ul><li>SynchronousQueue:直接提交的队列。没有容量。每一个插入操作都要等待一个相应的删除操作。反之亦是。提交的任务不会被真实的保存。而总是直接将新任务提交给线程执行。如果没有空闲的进程，则尝试创建新的进程，如果达到最大值则执行拒绝策略。</li><li>ArrayBlockingQueue：有界的任务队列。若有新的任务要执行，如果线程数量小于corePoolSize,则会优先创建新的线程。若大于corepoolSize,则加入等待队列。若队列已满，则在不大于maximumPoolsize的前提下创建新的线程。若大于maximumPoolsize则执行拒绝策略。</li><li>LinkedBlockingDeque：无界的任务队列。小于corePoolSize则会生成新的线程执行任务。当达到corePoolSize后，不会继续增加。若后续有新的任务加入，而又无空闲线程，则直接进入等待队列。</li><li>PriorityBlockingQueue：优先任务队列。带有优先级的无界队列。</li></ul><p>两种线程池的创建源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                     0L, TimeUnit.MILLISECONDS,</div><div class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">   &#125;</div><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">       return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                     60L, TimeUnit.SECONDS,</div><div class="line">                                     new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置的拒绝策略：</p><ul><li>AbortPolicy:直接抛出异常，阻止系统正常工作</li><li>CallerRunsPolicy:只要线程池未关闭，直接在调用者线程中，运行当前被丢弃的任务。</li><li>DiscardOldestPolicy:丢弃最老的一个请求。也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy：默默丢弃任务，不做任何处理。</li></ul><p>也可以自己扩展拒绝策略：<br>该接口的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface RejectedExecutionHandler &#123;</div><div class="line">    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>自定义线程创建：<br>ThreadFactory接口的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ThreadFactory &#123;</div><div class="line">    Thread newThread(Runnable r);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h3><p>ThreadPoolExecutor是一个可扩展的线程，它提供了三个方法：<br>beforeExecute(),afterExecute(),terminated()对线程池进行控制。<br>ThreadPoolExecutor.runWorker()方法的部分实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">                  beforeExecute(wt, task);</div><div class="line">                  Throwable thrown = null;</div><div class="line">                  try &#123;</div><div class="line">                      task.run();</div><div class="line">                  &#125; catch (RuntimeException x) &#123;</div><div class="line">                      thrown = x; throw x;</div><div class="line">                  &#125; catch (Error x) &#123;</div><div class="line">                      thrown = x; throw x;</div><div class="line">                  &#125; catch (Throwable x) &#123;</div><div class="line">                      thrown = x; throw new Error(x);</div><div class="line">                  &#125; finally &#123;</div><div class="line">                      afterExecute(task, thrown);</div><div class="line">                  &#125;</div></pre></td></tr></table></figure></p><p>可以自己实现这三个方法进行扩展。</p><h3 id="优化线程池线程数量"><a href="#优化线程池线程数量" class="headerlink" title="优化线程池线程数量"></a>优化线程池线程数量</h3><p>只要避免极大或极小的情况，线程池的大小对系统的性能不会影响太大。</p><ul><li>Ncpu = CPU的数量</li><li>Ucpu = 目标CPU的使用率（0&lt;Ucpu&lt;1)</li><li>W/C = 等待时间与计算时间的比率</li><li>为保持处理器达到期望的使用率，最优的池的大小为：<br>Nthreads = Ncpu <em> Ucpu </em>(1+W/C);</li></ul><p>Runtime.getRuntime().availableProcessors():得到可用的CPU数量。</p><h3 id="在线程池中寻找堆栈"><a href="#在线程池中寻找堆栈" class="headerlink" title="在线程池中寻找堆栈"></a>在线程池中寻找堆栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class DivTask implements Runnable</div><div class="line">int a,b;</div><div class="line">public DivTask(int a,int b)&#123;</div><div class="line">this.a = a;</div><div class="line">this.b = b;</div><div class="line">&#125;</div><div class="line">public void run() &#123;</div><div class="line">double re = a/b;</div><div class="line">System.out.println(re);</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(0, </div><div class="line">Integer.MAX_VALUE, 0L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">for(int i=0;i&lt;5;i++)&#123;</div><div class="line">poolExecutor.submit(new DivTask(100, i));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上程序只会输出4个数字。也不会抛出任何错误。所以线程池可能会“吃掉”程序抛出的错误。可以通过以下方法找回异常堆栈。</p><ol><li>放弃submit,改用execute()方法。</li><li>或者改成：Future re = pools.submit(new DivTask(100,i));re.get();</li></ol><p>但是以上两种方法只是打印出部分异常。而任务具体的提交位置也没有打印出来。为了得到更丰富的异常信息。我们可以重写ThreadPoolExecutor的提交线程的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class TraceThreadPoolExecutor extends ThreadPoolExecutor&#123;</div><div class="line">public TraceThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,</div><div class="line">BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void execute(Runnable task) &#123;</div><div class="line">super.execute(wrap(task, clientTrace(), Thread.currentThread().getName()));</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">return super.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</div><div class="line">&#125;</div><div class="line">private Exception clientTrace()&#123;</div><div class="line">return new Exception(&quot;client stack trace&quot;);</div><div class="line">&#125;</div><div class="line">private Runnable wrap(final Runnable task,final Exception clientStack,String clientThreadName)&#123;</div><div class="line">return new Runnable() &#123;</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">task.run();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">clientStack.printStackTrace();</div><div class="line">try &#123;</div><div class="line">throw e;</div><div class="line">&#125; catch (Exception e1) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e1.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>用自定义的线程提交任务便可打印出异常信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Executor接口：顶级接口。只有一个方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;execute(Runnable command)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ThreadPoolExecutor类实现类这个接口，任何Runnable的对象都可以被Th
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>java锁详解</title>
    <link href="http://yoursite.com/2017/10/24/01/"/>
    <id>http://yoursite.com/2017/10/24/01/</id>
    <published>2017-10-24T10:13:55.000Z</published>
    <updated>2017-10-25T11:46:13.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode或锁信息等。</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果当前对象是数组）</td></tr></tbody></table><p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p><table><thead><tr><th>无锁</th><th>25 bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：</p><table><thead><tr><th>锁状态</th><th>锁标志位</th></tr></thead><tbody><tr><td>轻量级锁</td><td>00</td></tr><tr><td>重量级锁</td><td>01</td></tr><tr><td>GC标记</td><td>11</td></tr><tr><td>偏向锁</td><td>01</td></tr></tbody></table><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p>偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p><p>偏向锁在Java 6和Java 7里是默认启用的。可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁加锁：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p>轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</p><p>一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程。</p><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td><td></td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>当竞争存在时，如果线程可以很快获得锁，那么可以不在OS层挂起线程，让线程做几个空操作（自旋）</p><p>JDK1.6中-XX:+UseSpinning开启</p><p>JDK1.7中，去掉此参数，改为内置实现。</p><h3 id="内置于JVM中的获取锁的优化方法和获取锁的步骤"><a href="#内置于JVM中的获取锁的优化方法和获取锁的步骤" class="headerlink" title="内置于JVM中的获取锁的优化方法和获取锁的步骤"></a>内置于JVM中的获取锁的优化方法和获取锁的步骤</h3><ul><li>偏向锁可用会先尝试偏向锁</li><li>轻量级锁可用会先尝试轻量级锁</li><li>以上都失败，尝试自旋锁</li><li>　再失败，尝试普通锁，使用OS互斥量在操作系统层挂起</li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JAVA虚拟机在JTI编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。(Vector,StringBuffer)。锁消除涉及到一项技术：逃逸分析。就是观察某一个变量是否会逃出某个作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</div></pre></td></tr></table></figure><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ol><li>减小锁持有时间</li><li>减小锁粒度(ConcurrentHashMap)</li><li>锁分离（LinkedBlockQueue)</li><li>锁粗化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;java对象头&quot;&gt;&lt;a href=&quot;#java对象头&quot; class=&quot;headerlink&quot; title=&quot;java对象头&quot;&gt;&lt;/a&gt;java对象头&lt;/h3&gt;&lt;p&gt;锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出epoll</title>
    <link href="http://yoursite.com/2017/10/24/04/"/>
    <id>http://yoursite.com/2017/10/24/04/</id>
    <published>2017-10-24T10:13:55.000Z</published>
    <updated>2017-11-10T05:34:38.565Z</updated>
    
    <content type="html"><![CDATA[<p>缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。</p><p>假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</p><p>假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</p><p>但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。</p><p>假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</p><p>也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</p><p>为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流</p><p>上文提到了epoll可以将哪个流发生了什么事件主动通知，而不需要轮询。那么到底是如何实现通知的呢？</p><p>这就和操作系统的原理相关，在内核的最底层是中断，类似系统回调的机制。网卡设备对应一个中断号, 当网卡收到网络端的消息的时候会向CPU发起中断请求, 然后CPU处理该请求. 通过驱动程序 进而操作系统得到通知, 系统然后通知epoll, epoll通知用户代码。它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p><p>epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。</p><h3 id="epoll和select的区别"><a href="#epoll和select的区别" class="headerlink" title="epoll和select的区别"></a>epoll和select的区别</h3><p>进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select;这样select/poll可以帮我们侦测许多fd是否就绪；但是select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限。linux还提供了一个epoll系统调用，epoll是基于事件驱动方式，而不是顺序扫描,当有fd就绪时，立即回调函数rollback。</p><p>nio在Linux下，内核版本大于2.6时使用epoll，小于2.6时使用poll</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。&lt;/p&gt;
&lt;p&gt;假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。&lt;/p&gt;
&lt;p&gt;假设一开
      
    
    </summary>
    
      <category term="Nio" scheme="http://yoursite.com/categories/Nio/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Nio" scheme="http://yoursite.com/tags/Nio/"/>
    
  </entry>
  
  <entry>
    <title>java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2017/10/24/02/"/>
    <id>http://yoursite.com/2017/10/24/02/</id>
    <published>2017-10-24T08:09:36.000Z</published>
    <updated>2017-10-25T12:04:00.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>是一块较小的内存空间，字节码解析器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令。程序的分支、循环、跳转、异常处理以及线程恢复等基础功能都是依赖程序计数器来完成。<br>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间片来实现，因此，为了确保线程切换之后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，因此程序计数器是线程私有的内存。<br>程序计数器是java虚拟机中唯一一个没有规定任何内存溢出OutOfMemoryError的内存区域。</p><h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行时都会同时创建一个栈帧用于存放局部变量表、操作数栈、动态连接和方法出口等信息。每个方法被调用直至执行完成过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>Java虚拟机栈有两种异常状况：如果线程请求的栈深度大于虚拟机所允许的最大深度时，抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够内存时会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与java虚拟机栈作用非常类似，其区别是：java虚拟机栈是为虚拟机执行java方法服务，而本地方法栈是为虚拟机调用的操作系统本地方法服务。HotSpot不区分本地方法栈和虚拟机栈。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是java虚拟机所管理的内存区域中最大一块，java堆是被所有线程所共享的一块内存区域，在java虚拟机启动时创建，堆内存的唯一目的就是存放对象实例。几乎所有的对象实例都是在堆分配内存。<br>Java堆是垃圾收集器管理的主要区域，从垃圾回收的角度看，由于现在的垃圾收集器基本都采用的是分代收集算法，因此java堆还可以初步细分为新生代和年老代。<br>Java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现上即可以是固定大小的，也可以是可动态扩展的。如果在堆中没有内存完成实例分配，并且堆大小也无法在扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与堆一样，是被各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是方法区却有一个别名叫Non-Heap(非堆)。</p><p>Sun HotSpot虚拟机把方法区叫永久代(Permanent Generation)，其他虚拟机没有永久代的概念。方法区中最重要的部分是运行时常量池。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面变量、符号引用、直接引用等，这些内容将在类加载后存放到方法区的运行时常量池中，另外在运行期间也可以将新的常量存放到常量池中，如String的intern()方法。<br>方法区和运行时常量池在无法满足内存分配时，也会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是java虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是在java开发中还是会使用到。<br>JDK1.4中新引入的NIO(new I/O)，引入了一种基于通道(Channel)和缓冲区(Buffer)的I/O方式，可以使用操作系统本地方法库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为堆外直接内存的引用进行操作，避免了java堆内存和本地直接内存间的数据拷贝，可以显著提高性能。<br>虽然直接内存并不直接收到java虚拟机内存影响，但是如果java虚拟机各个内存区域总和大于物理内存限制，从而导致直接内存不足，动态扩展时也会抛出OutOfMemoryError异常。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化。如果没有则执行类加载过程。</p><p>类加载检查通过后，虚拟机为对象分配内存。对象所需内存的大小在类加载完成后完全确定。假设java堆是绝对规整的，空闲内存与用过的内存中间有个指针，分配的时候就是把指针向空闲空间那边移动一段与对象大小相等的距离。这种分配方式称为“指针碰撞”。如果不是规整的，虚拟机就维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一个足够大的空间划分给对象。并更新列表上的记录。这种分配方式便是”空闲列表“。</p><p>还有一个并发问题，有两种解决方案：</p><ol><li>对分配内存空间的动作进行同步处理。实际上虚拟机采用CAS配上失败重试的方法保证更新操作的原子性。</li><li>把内存分配的动作按照线程划分在不同的空间之中进行。即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB。哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否采用TALB,通过参数-XX:+/-UseTLAB设定。</li></ol><p>内存分配完成后虚拟机将分配到的空间都初始化为0值（不包括对象头）。保证对象的实例字段在java代码中可以不赋初始值就可以直接使用。</p><p>接下来，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码等信息，这些信息存放在对象的对象头之中。</p><p>执行完new指令之后，接下来会执行<init>方法。进行初始化。</init></p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中储存的布局可以分为3块区域：对象头，实例数据和对齐填充。</p><p>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身运行时数据，如哈希码，GC分代年龄，锁状态标志等。对象头的另外一部分是类型指针。即指向它的类元数据的指针。虚拟机通过这个指针确定对象是哪个类的实例。注意，并不是所有的虚拟机实现都必须在对象数据上保留类型指针。如果是java数组，在对象头还需要有一块用于记录数组长度的数据。因为虚拟机无法从数组的元数据中确定数组的大小。而普通对象可以。</p><p>实例数据才是对象真正储存的有效信息。也是在程序代码中所定义的各种类型的字段内容。HotSpot虚拟机把相同宽度的字段分配在一起。满足这一前提下，父类中定义的变量出现在子类前面。</p><p>对齐填充并不是必然存在的。HotSpot虚拟机的自动内存管理要求对象起始地址必须是8字节的整数倍。也就是说对象的大小必须是8字节的整数倍，而对象头正好是8字节的整数倍。因此当实例数据没有对齐时需要填充。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>java程序需要通过栈上的reference数据来操作堆上的具体对象。reference类型只规定了一个指向对象的引用。目前主流的有使用句柄和直接指针两种。</p><ol><li>使用句柄，java堆中划分出一块内存来作为句柄池，reference储存的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据的各自的具体地址信息。</li><li>直接内存访问，reference存储的是对象地址，而对象里面应该有一个到对象类型数据的指针。</li></ol><h3 id="简单虚拟机参数"><a href="#简单虚拟机参数" class="headerlink" title="简单虚拟机参数"></a>简单虚拟机参数</h3><ul><li>-Xmx,-Xms:堆的最大值与最小值</li><li>-Xss:栈容量</li><li>MaxPermSize:最大方法区容量。</li></ul><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>intern方法的作用：如果字符串常量池中已经包含一个等于String对象的字符串，则返回代表池中这个字符创的对象。否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">String a = new String(&quot;ab&quot;);</div><div class="line">String b = new String(&quot;ab&quot;);</div><div class="line">String c = &quot;ab&quot;;</div><div class="line">String d = &quot;a&quot; + &quot;b&quot;;</div><div class="line">String e = &quot;b&quot;;</div><div class="line">String f = &quot;a&quot; + e;</div><div class="line"></div><div class="line">System.out.println(b.intern() == a);//false</div><div class="line">System.out.println(b.intern() == c);//true</div><div class="line">System.out.println(b.intern() == d);//true</div><div class="line">System.out.println(b.intern() == f);//false</div><div class="line">System.out.println(b.intern() == a.intern());//true</div></pre></td></tr></table></figure></p><p>JKD1.6中，intern()方法会在首次遇到的字符串复制到永久代中，返回的也是永久代中这个字符串的引用。而由StrignBuilder创建的字符串实例在java堆上，所以不是同一个引用。JKD1.7不会再复制实例。只是在常量池中记录首次出现的实例引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;p&gt;是一块较小的内存空间，字节码解析器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令。程序的分支、循环、跳
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://yoursite.com/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>
